<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[centos+git+gitolite 安装和部署]]></title>
    <url>%2F2018%2F05%2F30%2Fcentos-git-gitolite%2F</url>
    <content type="text"><![CDATA[部署环境：CentOS 6.8x64，git默认使用SSH协议，在服务器上基本上不用怎么配置就能直接使用。但是如果面向团队服务，需要控制权限的话，还是用gitolite方便些。一般来说，配置git服务器的话，需要一台服务器，还需要一个客户端来验证服务器是否搭建成功，而一般开发者基本都只有一台服务器，那就需要这台服务器既作为Git的服务器，又要作为客户端来使用了，下面的教程就是以服务器和客户端都是同一台服务器为例的。如果需要服务器和客户端分开的话，只需要将下面列出的服务器端和客户端的操作到相应的机器上操作就可以了。 创建git服务器专用账户（服务器端）：1、创建用户git，并设置密码 12[root@iZbp1c8ppw4ox72sq8z6hkZ ~]# useradd -m -s /bin/bash git[root@iZbp1c8ppw4ox72sq8z6hkZ ~]# passwd git 2、切换到git用户，在家目录/home/git下创建安装目录bin 12345678910[root@iZbp1c8ppw4ox72sq8z6hkZ ~]# su - git[git@iZbp1c8ppw4ox72sq8z6hkZ ~]# mkdir bin[git@iZbp1c8ppw4ox72sq8z6hkZ ~]# lltotal 24drwxr-xr-x 3 git git 4096 Aug 20 10:38 ./drwxr-xr-x 8 root root 4096 Aug 20 10:36 ../-rw-r--r-- 1 git git 220 Apr 3 2012 .bash_logout-rw-r--r-- 1 git git 3486 Apr 3 2012 .bashrcdrwxrwxr-x 2 git git 4096 Aug 20 10:38 bin/-rw-r--r-- 1 git git 675 Apr 3 2012 .profile 3、获取 Gitolite 并安装，gitolite要安装在服务器端，安装之前要保证系统上已经安装了git 12345678910111213141516171819202122[git@iZbp1c8ppw4ox72sq8z6hkZ ~]# git clone https://github.com/sitaramc/gitolite[git@iZbp1c8ppw4ox72sq8z6hkZ ~]# lltotal 28drwxr-xr-x 4 git git 4096 Aug 20 10:40 ./drwxr-xr-x 8 root root 4096 Aug 20 10:36 ../-rw-r--r-- 1 git git 220 Apr 3 2012 .bash_logout-rw-r--r-- 1 git git 3486 Apr 3 2012 .bashrcdrwxrwxr-x 2 git git 4096 Aug 20 10:38 bin/drwxr-xr-x 6 git git 4096 Aug 20 10:40 gitolite/-rw-r--r-- 1 git git 675 Apr 3 2012 .profile[git@iZbp1c8ppw4ox72sq8z6hkZ ~]# gitolite/install -ln[git@iZbp1c8ppw4ox72sq8z6hkZ ~]# lltotal 28drwxr-xr-x 4 git git 4096 Aug 20 10:40 ./drwxr-xr-x 8 root root 4096 Aug 20 10:36 ../-rw-r--r-- 1 git git 220 Apr 3 2012 .bash_logout-rw-r--r-- 1 git git 3486 Apr 3 2012 .bashrcdrwxrwxr-x 2 git git 4096 Aug 20 10:44 bin/drwxr-xr-x 6 git git 4096 Aug 20 10:40 gitolite/-rw-r--r-- 1 git git 675 Apr 3 2012 .profile 创建 Gitolite 服务器管理员用户，并创建管理员用户密钥（客户端）：因为我们是在同一台服务器上，直接exit退回到root用户，之后变身为客户端模式，如果客户端和服务器分开的话，不需要exit指令了，直接在客户端执行添加用户的指令就可以了。这里的Gitolite服务器管理员用户名我们叫gitAdmin 1、创建用户git，并设置密码 12[root@iZbp1c8ppw4ox72sq8z6hkZ ~]# useradd -m -s /bin/bash gitAdmin[root@iZbp1c8ppw4ox72sq8z6hkZ ~]# passwd gitAdmin 2、切换到gitAdmin用户 123456789[root@iZbp1c8ppw4ox72sq8z6hkZ ~]# su - gitAdmin[gitAdmin@iZbp1c8ppw4ox72sq8z6hkZ ~]# lltotal 24drwxr-xr-x 3 gitAdmin gitAdmin 4096 Aug 20 10:48 ./drwxr-xr-x 9 root root 4096 Aug 20 10:46 ../-rw-r--r-- 1 gitAdmin gitAdmin 220 Apr 3 2012 .bash_logout-rw-r--r-- 1 gitAdmin gitAdmin 3486 Apr 3 2012 .bashrc-rw-r--r-- 1 gitAdmin gitAdmin 675 Apr 3 2012 .profiledrwxrwxr-x 2 gitAdmin gitAdmin 4096 Aug 20 10:48 .ssh/ 3、创建用户密钥 1[gitAdmin@iZbp1c8ppw4ox72sq8z6hkZ ~]# ssh-keygen -t rsa 4、将管理员公钥（gitAdmin.pub)复制 到服务器上的 git 用户的家目录下 12345678910111213141516[gitAdmin@iZbp1c8ppw4ox72sq8z6hkZ ~]# exitlogout[root@iZbp1c8ppw4ox72sq8z6hkZ ~]# cp /home/gitAdmin/.ssh/gitAdmin.pub /home/git/[root@iZbp1c8ppw4ox72sq8z6hkZ ~]# ll /home/gittotal 36drwxr-xr-x 4 git git 4096 Aug 20 10:53 ./drwxr-xr-x 9 root root 4096 Aug 20 10:46 ../-rw------- 1 git git 788 Aug 20 10:45 .bash_history-rw-r--r-- 1 git git 220 Apr 3 2012 .bash_logout-rw-r--r-- 1 git git 3486 Apr 3 2012 .bashrcdrwxrwxr-x 2 git git 4096 Aug 20 10:44 bin/-rw-r--r-- 1 root root 412 Aug 20 10:53 gitAdmin.pubdrwxr-xr-x 6 git git 4096 Aug 20 10:40 gitolite/-rw-r--r-- 1 git git 675 Apr 3 2012 .profile 配置 Gitolite 服务器（服务器端）：123456789101112131415161718192021222324252627[root@iZbp1c8ppw4ox72sq8z6hkZ ~]# su - git[git@iZbp1c8ppw4ox72sq8z6hkZ ~]# gitolite setup -pk gitAdmin.pubInitialized empty Git repository in /home/git/repositories/gitolite-admin.git/Initialized empty Git repository in /home/git/repositories/testing.git/WARNING: /home/git/.ssh missing; creating a new one (this is normal on a brand new install)WARNING: /home/git/.ssh/authorized_keys missing; creating a new one (this is normal on a brand new install)[git@iZbp1c8ppw4ox72sq8z6hkZ ~]# lltotal 60drwxr-xr-x 7 git git 4096 Aug 20 10:57 ./drwxr-xr-x 9 root root 4096 Aug 20 10:46 ../-rw------- 1 git git 788 Aug 20 10:45 .bash_history-rw-r--r-- 1 git git 220 Apr 3 2012 .bash_logout-rw-r--r-- 1 git git 3486 Apr 3 2012 .bashrcdrwxrwxr-x 2 git git 4096 Aug 20 10:44 bin/-rw-r--r-- 1 root root 412 Aug 20 10:53 gitAdmin.pubdrwxr-xr-x 6 git git 4096 Aug 20 10:40 gitolite/drwx------ 6 git git 4096 Aug 20 10:57 .gitolite/-rw------- 1 git git 6662 Aug 20 10:57 .gitolite.rc-rw-r--r-- 1 git git 675 Apr 3 2012 .profile-rw------- 1 git git 12 Aug 20 10:57 projects.listdrwx------ 4 git git 4096 Aug 20 10:57 repositories/drwx------ 2 git git 4096 Aug 20 10:57 .ssh/ 验证Gitolite管理员账户访问服务器的别名以及验证别名是否成功（客户端）：1、切换到gitAdmin账户 1234567891011[git@iZbp1c8ppw4ox72sq8z6hkZ ~]# exitlogout[root@iZbp1c8ppw4ox72sq8z6hkZ ~]# su - gitAdmin[gitAdmin@iZbp1c8ppw4ox72sq8z6hkZ ~]# ll .ssh/total 16drwxrwxr-x 2 gitAdmin gitAdmin 4096 Aug 20 10:49 ./drwxr-xr-x 3 gitAdmin gitAdmin 4096 Aug 20 10:53 ../-rw------- 1 gitAdmin gitAdmin 1679 Aug 20 10:49 gitAdmin-rw-r--r-- 1 gitAdmin gitAdmin 412 Aug 20 10:49 gitAdmin.pub[gitAdmin@iZbp1c8ppw4ox72sq8z6hkZ ~]# vi .ssh/config 2、在.ssh文件夹下新建config文件，输入下面内容 12345host git user git hostname xxx.xxx.xxx.xxx port 22 identityfile ~/.ssh/gitAdmin host： 随便定义，用于客户端标识所连接服务端的名字；user ：随便定义hostname ：服务器主机名，或者直接填写服务器 IP 地址；port：服务器的ssh访问端口，默认22；identityfile ：管理员登录服务器所使用的验证密钥； 3、使用服务器别名从 Gitolite 服务器 clone Gitolite 服务器管理仓库 gitolite-admin ，验证别名配置是否成功，以下表示已经clone成功了： 1234567891011[gitAdmin@iZbp1c8ppw4ox72sq8z6hkZ ~]# git clone git@git:gitolite-adminCloning into &apos;gitolite-admin&apos;...The authenticity of host &apos;xxx.xxx.xxx.xxx (xxx.xxx.xxx.xxx)&apos; can&apos;t be established.ECDSA key fingerprint is c1:c2:6a:7a:68:c8:e5:a6:87:f4:9b:95:d5:fd:ff:09.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added &apos;xxx.xxx.xxx.xxx&apos; (ECDSA) to the list of known hosts.remote: Counting objects: 6, done.remote: Compressing objects: 100% (4/4), done.Receiving objects: 100% (6/6), 763 bytes, done.remote: Total 6 (delta 0), reused 0 (delta 0) 添加新项目以及分配权限（客户端）：1、先登录进入客户端，查看家目录对应文件 12345678910111213[gitAdmin@iZbp1c8ppw4ox72sq8z6hkZ ~]# ll -atotal 40drwx------ 4 gitadmin gitadmin 4096 May 24 09:18 .drwxr-xr-x. 8 root root 4096 May 22 14:48 ..-rw------- 1 gitadmin gitadmin 2818 May 31 00:32 .bash_history-rw-r--r-- 1 gitadmin gitadmin 18 Mar 23 2017 .bash_logout-rw-r--r-- 1 gitadmin gitadmin 176 Mar 23 2017 .bash_profile-rw-r--r-- 1 gitadmin gitadmin 124 Mar 23 2017 .bashrc-rw-rw-r-- 1 gitadmin gitadmin 53 May 20 20:49 .gitconfigdrwxr-xr-x 5 gitadmin gitadmin 4096 May 20 20:26 gitolite-admindrwx------ 2 gitadmin gitadmin 4096 May 20 20:26 .ssh-rw------- 1 gitadmin gitadmin 789 May 24 09:18 .viminfo 2、进入gitolite-admin目录，该目录就是管理项目和权限目录 12345678910111213141516171819[gitAdmin@iZbp1c8ppw4ox72sq8z6hkZ ~]# cd gitolite-admin[gitAdmin@iZbp1c8ppw4ox72sq8z6hkZ gitolite-admin]$ lltotal 8drwxrwxr-x 2 gitadmin gitadmin 4096 May 24 09:18 confdrwxrwxr-x 2 gitadmin gitadmin 4096 May 22 16:32 keydir[gitAdmin@iZbp1c8ppw4ox72sq8z6hkZ gitolite-admin]$ ll keydir/total 20-rw-rw-r-- 1 gitadmin gitadmin 390 May 20 22:48 bijiben.pub-rw-r--r-- 1 root root 401 May 22 16:32 company.pub-rw-rw-r-- 1 gitadmin gitadmin 414 May 20 20:26 gitadmin.pub-rw-r--r-- 1 root root 410 May 22 15:23 test.pub-rw-rw-r-- 1 gitadmin gitadmin 397 May 20 23:23 xiaoming.pub[gitAdmin@iZbp1c8ppw4ox72sq8z6hkZ gitolite-admin]$ ll conf/total 4-rw-rw-r-- 1 gitadmin gitadmin 146 May 24 09:18 gitolite.conf keydir目录就是放密钥的，公司员工在自己电脑生成密钥，然后给到管理员上传到该目录，分配对应项目权限即可，员工自己配置别名克隆项目就好了 conf目录是配置项目以及分配权限的目录 3、打开gitolite.conf 1[gitAdmin@iZbp1c8ppw4ox72sq8z6hkZ gitolite-admin]$ vim conf/gitolite.conf 如图所示： 上面的配置含义是： 定义一个用户组： user 定义三个版本库： gitolite-admin 、testing 和 shop 项目gitolite-admin只有gitadmin用户才有权限操作 项目testing表示所有用户都可以进行操作 用户组成员对项目shop有（读 写 删除）RW+ 权限 一个组中有多个用户，则以空格为分割 4、每次修改这两个目录需要提交修改 1234[gitadmin@iZbp1c8ppw4ox72sq8z6hkZ gitolite-admin]$ git add .[gitadmin@iZbp1c8ppw4ox72sq8z6hkZ gitolite-admin]$ git status[gitadmin@iZbp1c8ppw4ox72sq8z6hkZ gitolite-admin]$ git commit -m &quot;test&quot;[gitadmin@iZbp1c8ppw4ox72sq8z6hkZ gitolite-admin]$ git push origin master 至此已经完成了 （扩展）windows下克隆项目1、生成对应密钥，并上传到客户端1ssh-keygen -t rsa 2、创建config文件，并配置别名如图所示： 然后直接输入下边命令克隆即可（如果你的账户有权限包括git其他命令也可以使用、git push origin master等等） 1git clone git@bijiben:testing 如果我还有其他的git服务器也要提交项目代码怎么办？很简单，生成多一个密钥，指定对应别名，如上图我还要对github.com网站上的项目进行提交代码，所以我就多生成一个密钥，在本地项目重新指定即可假设我本地原本已经有了https://github.com/vonfly/vonfly.github.io.git这个项目了，只不过之前的密钥给删除了，或者覆盖了，我如何重新进行关联呢？ 首先先在登录你github账户上，在本地找到 github.pub文件，用编辑器打开，复制其中的全部内容。登陆你的GitHub账户，依次点击账号Settings &gt; SSH and GPG keys &gt; new SSH key，把github.pub中的内容拷贝进去key项，title项随意填 。 至此就已经配置完SSH-Key了 然后本地执行下边代码进行重新关联 12git remote rm origingit remote add origin git@github:vonfly/vonfly.github.io.git 之后就可以执行git的提交和更新等操作了 （扩展）使用git钩子完善完美的git服务器（暂时不知道怎么描述，因为有很多也不是很懂）：1、首先，我们切换到gitadmin 用户（客户端），来到gitolite-admin/conf/目录下，在gitolite.conf中添加一个新的仓库，名字为：dong-admin vim编辑后如下图 操作步骤如下图 2、切换到git用户（服务端）,进入repositories目录，已经有了dong-admin.git 1234567[git@iZbp1c8ppw4ox72sq8z6hkZ ~]$ cd repositories/[git@iZbp1c8ppw4ox72sq8z6hkZ repositories]$ lltotal 16drwx------ 7 git git 4096 May 31 20:56 dong-admin.gitdrwx------ 8 git git 4096 May 31 20:56 gitolite-admin.gitdrwx------ 7 git git 4096 May 31 20:56 shop.gitdrwx------ 7 git git 4096 May 31 20:56 testing.git 我们查看一下dong-admin.git目录里都有什么： 12345678910111213[git@iZbp1c8ppw4ox72sq8z6hkZ repositories]$ cd dong-admin.git/[git@iZbp1c8ppw4ox72sq8z6hkZ dong-admin.git]$ lltotal 36drwx------ 2 git git 4096 May 31 20:56 branches-rw------- 1 git git 66 May 31 20:56 config-rw------- 1 git git 73 May 31 20:56 description-rw------- 1 git git 0 May 31 20:56 git-daemon-export-ok-rw------- 1 git git 123 May 31 20:56 gl-conf-rw------- 1 git git 23 May 31 20:56 HEADdrwx------ 2 git git 4096 May 31 20:56 hooksdrwx------ 2 git git 4096 May 31 20:56 infodrwx------ 4 git git 4096 May 31 20:56 objectsdrwx------ 4 git git 4096 May 31 20:56 refs 别的目录都不要管，可以看到有个hooks目录，继续查看 1234567891011121314[git@iZbp1c8ppw4ox72sq8z6hkZ dong-admin.git]$ cd hooks/[git@iZbp1c8ppw4ox72sq8z6hkZ hooks]$ lltotal 44-rwx------ 1 git git 452 May 31 20:56 applypatch-msg.sample-rwx------ 1 git git 896 May 31 20:56 commit-msg.sample-rwx------ 1 git git 160 May 31 20:56 post-commit.sample-rwx------ 1 git git 548 May 31 20:56 post-receive.sample-rwx------ 1 git git 189 May 31 20:56 post-update.sample-rwx------ 1 git git 398 May 31 20:56 pre-applypatch.sample-rwx------ 1 git git 1578 May 31 20:56 pre-commit.sample-rwx------ 1 git git 1239 May 31 20:56 prepare-commit-msg.sample-rwx------ 1 git git 4951 May 31 20:56 pre-rebase.samplelrwxrwxrwx 1 git git 39 May 31 20:56 update -&gt; /home/git/.gitolite/hooks/common/update-rwx------ 1 git git 3611 May 31 20:56 update.sample 好了，这里就是我们要找的目录了，我们需要在这个目录下创建钩子文件：使用vim 创建一个新文件 1[git@iZbp1c8ppw4ox72sq8z6hkZ hooks]$]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>Centos</tag>
        <tag>gitolite</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows下安装yii]]></title>
    <url>%2F2017%2F06%2F01%2Fyii-install%2F</url>
    <content type="text"><![CDATA[通过 Composer 安装 Packagist / Composer中国全量镜像先安装 Composer安装前请务必确保已经正确安装了 PHP。打开命令行窗口并执行 php -v 查看是否正确输出版本号。打开命令行并依次执行下列命令安装最新版本的 Composer： 1php -r &quot;copy(&apos;https://install.phpcomposer.com/installer&apos;, &apos;composer-setup.php&apos;);&quot; 1php composer-setup.php 1php -r &quot;unlink(&apos;composer-setup.php&apos;);&quot; 说明：执行第一条命令下载下来的 composer-setup.php 脚本将简单地检测 php.ini 中的参数设置，如果某些参数未正确设置则会给出警告；然后下载最新版本的 composer.phar 文件到当前目录。 上述 3 条命令的作用依次是： 下载安装脚本 － composer-setup.php － 到当前目录。执行安装过程。删除安装脚本。 全局安装全局安装是将 Composer 安装到系统环境变量 PATH 所包含的路径下面，然后就能够在命令行窗口中直接执行 composer 命令了。 Mac 或 Linux 系统：打开命令行窗口并执行如下命令将前面下载的 composer.phar 文件移动到 /usr/local/bin/ 目录下面： 1# sudo mv composer.phar /usr/local/bin/composer Windows 系统：1、找到并进入 PHP 的安装目录（和你在命令行中执行的 php 指令应该是同一套 PHP）。2、将 composer.phar 复制到 PHP 的安装目录下面，也就是和 php.exe 在同一级目录。3、在 PHP 安装目录下新建一个 composer.bat 文件，并将下列代码保存到此文件中。 1@php &quot;%~dp0composer.phar&quot; %* 最后重新打开一个命令行窗口试一试执行 composer –version 看看是否正确输出版本号。如图所示： 提示：不要忘了经常执行 composer selfupdate 以保持 Composer 一直是最新版本哦！ 1composer selfupdate //命令行中执行 Packagist 镜像使用方法系统全局配置： 即将配置信息添加到 Composer 的全局配置文件 config.json 中。见“方法一”单个项目配置： 将配置信息添加到某个项目的 composer.json 文件中。见“方法二” 方法一： 修改 composer 的全局配置文件（推荐方式）打开命令行窗口（windows用户）或控制台（Linux、Mac 用户）并执行如下命令： 1composer config -g repo.packagist composer https://packagist.phpcomposer.com 方法二： 修改当前项目的 composer.json 配置文件：打开命令行窗口（windows用户）或控制台（Linux、Mac 用户），进入你的项目的根目录（也就是 composer.json 文件所在目录），执行如下命令： 1composer config repo.packagist composer https://packagist.phpcomposer.com 上述命令将会在当前项目中的 composer.json 文件的末尾自动添加镜像的配置信息（你也可以自己手工添加）：“repositories”: { “packagist”: { “type”: “composer”, “url”: “https://packagist.phpcomposer.com&quot; }} 镜像原理：一般情况下，安装包的数据（主要是 zip 文件）一般是从 github.com 上下载的，安装包的元数据是从 packagist.org 上下载的。 然而，由于众所周知的原因，国外的网站连接速度很慢，并且随时可能被“墙”甚至“不存在”。 “Packagist 中国全量镜像”所做的就是缓存所有安装包和元数据到国内的机房并通过国内的 CDN 进行加速，这样就不必再去向国外的网站发起请求，从而达到加速 composer install 以及 composer update 的过程，并且更加快速、稳定。因此，即使 packagist.org、github.com 发生故障（主要是连接速度太慢和被墙），你仍然可以下载、更新安装包。 开始使用Composer 安装yii打开命令行，切换到一个可通过 Web 访问的目录（如我的是d:wamp/www），执行如下命令即可安装 Yii ： 123composer global require &quot;fxp/composer-asset-plugin:^1.2.0&quot;composer create-project --prefer-dist yiisoft/yii2-app-basic yiishop 第一条命令安装 Composer asset plugin， 它是通过 Composer 管理 bower 和 npm 包所必须的，此命令全局生效，一劳永逸。 第二条命令会将 Yii 安装在名为 yiishop 的目录中。如果你想使用其它目录名称，你可以选择其他目录名称。 注意: 在安装过程中 Composer 可能会询问你 GitHub 账户的认证信息，因为可能在使用中超过了 GitHub API （对匿名用户的）使用限制。因为 Composer 需要为所有扩展包从 GitHub 中获取大量信息，所以超限非常正常。（译注：也意味着作为程序猿没有 GitHub 账号，就真不能愉快地玩耍了）登陆 GitHub 之后可以得到更高的 API 限额，这样 Composer 才能正常运行。 如下图所示： 我们需要提供一个githtb token 供Composer检索使用具体操作：进入 https://github.com/settings/tokens 点击 「Generate new token」 新建一个 Token，选择默认新建就行，然后就会得到一个 Token，然后输入这个值就 OK 了。 最后等待就可以了，安装成功如下图： 学习yii中文社区]]></content>
  </entry>
  <entry>
    <title><![CDATA[memcache 内存缓存技术]]></title>
    <url>%2F2017%2F05%2F05%2Fmemcache%2F</url>
    <content type="text"></content>
      <categories>
        <category>缓存技术</category>
      </categories>
      <tags>
        <tag>nosql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[coreseek中文检索引擎]]></title>
    <url>%2F2017%2F05%2F04%2Fcoreseek%2F</url>
    <content type="text"><![CDATA[在 Centos6.5 上编译安装coreseek以及配置 下载对应安装包，并解压1# tar zxvf coreseek-3.2.14.tar.gz 先进入mmseg-3.2.14目录安装中文分词1234# ls# cd coreseek-3.2.14/mmseg-3.2.14///检测环境配置是否会报错# ./configure --prefix=/usr/local/mmseg 编译过程中报了一个config.status:error:cannot find input file:src/Makeefile.in这个的错误，然后运行以下指令再次编译就能通过了 1234567891011# aclocal# libtoolize --force# automake --add-missing# autoconf# autoheader# make clean# ./configure --prefix=/usr/local/mmseg//开始编译# make//进行安装# make install 到这里就安装完了mmseg 先进入csft-3.2.14目录安装csft1234567# ls# cd csft-3.2.14///检测环境配置是否会报错# ./configure --prefix=/usr/local/coreseek --with-mysql=/usr/local/mysql --with-mmseg=/usr/local/mmseg --with-mmseg-includes=/usr/local/mmseg/include/mmseg/ --with-mmseg-libs=/usr/local/mmseg/lib/# make# make install 到这里就安装完了csft 配置coreseek1234//进入配置目录# cd /usr/local/coreseek/etc//复制一份配置文件并改名为csft.conf，因为coreseek默认加载的配置文件是csft.conf# cp sphinx.conf.dist csft.conf vim csft.conf，修改为：如下图： 创建全文索引配置文件没有错误了，就可以开始创建全文索引了 1# /usr/local/coreseek/bin/indexer --all 用PHP连接使用Sphinx1、先到http://pecl.php.net/package/sphinx下载所需要的扩展库2、解压文件和进入解压目录 12# tar zxvf sphinx-1.3.3.tgz# cd sphinx-1.3.3 3、调用phpize，生成configure 12//注意此处是你服务器上php安装的地址# /usr/local/php/bin/phpize 4、检测环境配置 1# ./configure --with-php-config=/usr/local/php/bin/php-config --with-sphinx 报错，如下图：5、进入以下目录(之前coreseek-3.2.14的解压目录) 123# cd /usr/local/src/coreseek-3.2.14/csft-3.2.14/api/libsphinxclient# ./configure# make &amp;&amp; make install 6、重新到sphinx-1.3.3目录下执行 123# cd /usr/local/src/sphinx-1.3.3# ./configure --with-php-config=/usr/local/php/bin/php-config --with-sphinx# make &amp;&amp; make install 执行结果如下图：7、修改php下php.ini文件 1# vim /usr/local/php/etc/php.ini …….; For example, on Windows:;; extension=msql.dll;; … or under UNIX:;; extension=msql.soextension=sphinx.so //添加如下这行]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>nosql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongodb-php结合开发]]></title>
    <url>%2F2017%2F05%2F03%2Fmongodb-php%2F</url>
    <content type="text"><![CDATA[想要在PHP中调用mongobd需要安装mongodb的php扩展 下载最新的php mongodb扩展源码http://pecl.php.net/package/mongo 把扩展编译到php中12345678910111213//先解压文件# tar xzf mongo-1.2.6.tgz//进入解压后的目录# cd mongo-1.2.6//运行phpize来准备编译扩展环境# /usr/local/php/bin/phpize//查看编译参数# ./configure -h//开始编译(--with-php-config参数是告诉配置脚本php-cofig这个程序的路径)# ./configure --with-php-config=/usr/local/php/bin/php-config --enable-mongo//安装# make &amp;&amp; make install //打开配置文件php.ini，把mongodb模块打开（即增加extension=mongo.so）vim /usr/local/php/etc/php.ini….extension=msql.soextension=mongo.so 接下来重启apache 1# /usr/local/apache2/bin/apachect1 restart 最后查看php是否已经支持mongodb 1# cd /usr/local/apache2/htdocs/ vim phpinfo.php&lt;?phpphpinfo();最后浏览器访问该页面，搜索mongo，看是否有 实际操作在php的mongo扩展中，提供了4类接口(对象)：1、针对mongodb连接的操作：Mongo2、针对mongodb中数据库的操作：MongoDB3、针对mongodb中collection的操作：MongoCollection4、针对查询结果集的操作：MongoCursor PHP连接mongodb数据库文件conn.php的内容：&lt;?php$conn = new Mongo(‘mongodb://test1:123@localhost:27017/test’);$db = $conn-&gt;test;?&gt; 查询数据&lt;?phpinclude “conn.php”;$c1 = $db-&gt;c1;根据地址栏传过来_id查询数据//db.c1.find({_id:ObjectId(“dfd1dfjfkee”)});$oid = $_GET[‘oid’];$objectId = new MongoId($oid);$arr = array(‘_id’=&gt;$objectId);$rs = $c1-&gt;find($arr);var_dump($rs);$conn-&gt;close(); //关闭连接 增加数据&lt;?phpinclude “conn.php”;$c1 = $db-&gt;c1;//db.c1.insert({name:”user1000”});$arr = array(‘name’=&gt;’user1000’);if($c1-&gt;insert($arr)){ echo “插入成功！”;}else{ echo “插入失败！”;}$conn-&gt;close(); //关闭连接 删除数据&lt;?phpinclude “conn.php”;$c1 = $db-&gt;c1;//db.c1.remove({name:”user1000”});$arr = array(‘name’=&gt;’user1000’);if($c1-&gt;remove($arr)){ echo “删除成功！”;}else{ echo “删除失败！”;}$conn-&gt;close(); //关闭连接 修改数据&lt;?phpinclude ‘conn.php’;$c1 = $db-&gt;c1;//db.c1.update({name:”user1”}, {$set:{name:”user100”,sex:1}});$sarr = array(‘name’=&gt;’user1’);$darr = array(‘$set’=&gt;array(‘name’=&gt;’user100’, ‘sex’=&gt;1));$opts = array(‘upsert’=&gt;0, ‘multiple’=&gt;1);if($c1-&gt;update($sarr, $darr, $opts)){ echo “修改成功！”;}else{ echo “修改失败！”;}$conn-&gt;close(); //关闭连接]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>nosql</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongodb数据库一些简单操作]]></title>
    <url>%2F2017%2F05%2F02%2Fmongodb-operation%2F</url>
    <content type="text"><![CDATA[mongodb一些基本操作 进入(登录)客户端操作1# /usr/local/mongodb/bin/mongo 控制台(客户端)中的基本操作命令切换数据库：use test;显式创建数据库：db.createCollection(“a1”);查看当前操作的数据库：db;查看用户列表：db.system.users.find();查看所有用户：show users;查看所有数据库：show dbs;查看所有集合：show collections;删除当前数据库：db.dropDatabase();删除集合：db.user.drop(); //删除user集合想知道mongodb支持哪些命令：help;想知道当前数据库支持哪些方法：db.help();想知道当前集合支持哪些方法：db.user.help(); //查看user集合支持的方法终端清屏：cls 集合的增删改查操作查询user集合的记录db.user.find(); //查询全部记录db.user.find({name:”vonfly”}); //查询name为vonfly的记录db.user.findOne({name:”vonfly”}); //查询name为vonfly的第一条记录 向user集合插入一条记录db.user.insert({name:”vonfly”}); 修改记录(把name为vonfly的修改name为test)db.user.update({name:”vonfly”}, {$set: {name:”test”} }); 删除记录db.user.remove({name:”vonfly”}); //删除name为vonfly的记录db.user.remove(); //删除全部记录 增删改查的高级应用Capped Collectioin(固定集合)属性及用法属性1：对固定集合进行插入速度极快属性2：按照插入顺序的查询输出速度极快属性3：能够在插入最新数据时，淘汰最早的数据 用法1：储存日志信息用法2：缓存一些少量的文档 固定集合的创建（需要显式创建）//创建一个集合为vn_user的固定集合，大小为10000字节。还可以限定文档个数，加上max:100属性db.createCollection(“vn_user”, {capped:true, size:10000});注意：指定文档上限，必须指定大小。文档限制是在容量没满时进行淘汰，要是满了，就根据容量限制来进行淘汰 普通集合转换成固定集合db.runCommand({converTocapped:”test”, size:10000}); //把test普通集合转换成固定集合，大小为10000字节 自然排序固定集合文档按照插入顺序储存的，默认情况下查询就是按照插入顺序返回的，可以使用$natural调整返回顺序db.my_collection.find().sort({“$natural”: 1}); //1表示默认顺序，-1则相反 判断是否为固定集合db.test.isCapped(); //判断test集合是否为固定集合db.test.stats(); //或者用此命令，对应”capped”:1就是固定集合 GridFS大文件管理（使用mongofiles二进制程序）GridFS是一种在mongodb中存储大二进制文件的机制。GridFS使用两个表来存储数据：其中files是包含数据对象；chunks是包含其他一些相关信息的二进制块。使用的原因：1、储存巨大的文件，比如视频、高清图片等2、利用GridFS可以简化需求。3、GridFS可以避免用户上传内容的文件系统出现问题4、GridFS故障恢复和扩展很容易5、GridFS不产生磁盘碎片 查看mongofiles支持对应的参数 1# # /usr/local/mongodb/bin/mongofiles -h 上传文件 1# /usr/local/mongodb/bin/mongofiles put test.tar.gz 进入客户端，查看集合，会发现多了两个集合，fs.chunks和fs.files 下载文件 1# /usr/local/mongodb/bin/mongofiles get test.tar.gz 性能优化查看查询语句的执行计划(类似查看mysql语句执行所用的时间和影响的行数，目的就是要对语句进行优化，看需不需要建立索引)，使用以下语句进行查看 db.user.find({name:”user1”}).explain(); 建立索引（普通索引）//在user集合的name上建立索引db.user.ensureIndex({name:1}); //值1表示升序建立，-1表示降序建立索引 注意：当系统已经有大量数据时，创建索引会非常耗时，需要在后台执行，所以要指定参数background:truedb.user.ensureIndex({name:1}, {background:true}); 创建唯一索引db.user.ensureIndex({name:1}, {unique:true}); 简单查看索引db.user.getIndexKeys(); 查看索引详细信息db.user.getIndexes(); 删除索引//删除user集合中的所有索引db.user.dropIndexes(); //删除user集合中的name索引db.user.dropIndex({name:1}); 优化器profile(慢查询日志功能)mongodb database profiler 是一种慢查询日志功能，可以作为我们优化数据库的依据。 开启profile功能级别的值为：0表示不开启，1表示慢命令(默认为&gt;100ms)，2表示记录所有命令 方法1：启动mongodb时加上–profile=1 方法2：在客户端调用db.setProfilingLevel(级别)命令来实时配置 说明：1、profile信息是保存在system.profile中。我们可以通过db.getProfilingLevel()命令来获取当前的Profile级别2、profile在级别为1时会记录慢命令，默认的慢查询时间为100ms，修改默认时间有两种方法：一种是启动mongodb时加上–profile=1和–slowms=10； 第二种方式是用命令db.setProfilingLevel(1)，表示如果查询耗时超过10毫秒，就会被记录下来3、数据库profiler把数据写入 system.profile 集合中，该集合是一个 capped collection 。可以用普通的MongoDB查询语句查询 system.profile 集合得到profiler的输出。 优化总结1、创建索引，在查询条件的字段上，或者排序条件的字段上创建索引，可以提高执行效率，如db.user.ensureIndex({name:1});2、限定返回结果条数，使用limit()限定返回结果集的大小，可以减少database server的资源消耗，可以减少网络传输数据量。如db.user.find().limit(10);3、查询使用到的字段，不要查询所有字段。如db.user.find({}, {name:1,age:1}).sort({age:-1}).limit(10);4、采用cappedcollection(固定集合)，capped Collections比普通Collections的读写效率高5、采用profiling(慢查询日志功能)，profiling功能肯定是会影响效率的，但是不太严重，原因是它使用的是system.profile来记录，system.profile是一个capped collection(固定集合)，这种collection在操作上有一些限制和特点，但是效率高 mongodb主从集群mongodb支持在多个机器中通过异步复制达到故障转移和实现冗余。多机器中同一时刻只有一台是用于写操作。正是由于这个情况，为mongodb提供了数据一致性的保障。担当primary(主服务器)角色的机器能把读操作分发给slave(从服务器)。 replica sets复制（副本集）mongodb在1.6版本开发了replica set，主要增加了故障自动切换和自动修复成员节点，各个db之间数据完全一致，最为显著的区别在于，副本集没有固定的主节点，它是整个集群选举出的一个主节点，当其不工作时变更其他节点。（简单来说就是当主服务器挂了，那么剩余从服务器会自动选举一个出来做主服务器） 部署replica sets（测试）1、启动两个实例（模拟两个mongodb服务器）2、创建数据文件存储路径 12# mkdir -p /usr/local/mongodb/data/data1/# mkdir -p /usr/local/mongodb/data/data2/ 3、创建日志文件路径 12# mkdir -p /usr/local/mongodb/log/dblogs1# mkdir -p /usr/local/mongodb/log/dblogs2 4、创建key目录 1234567# mkdir -p /usr/local/mongodb/key/# cd /usr/local/mongodb/key/# touch key1# touch key2# echo &quot;123456&quot; &gt; key1# echo &quot;123456&quot; &gt; key2# chmod 600 * 5、启动一个实例 1# /usr/local/mongodb/bin/mongod --replSet rs1 --keyFile=/usr/local/mongodb/key/key1 --port 200001 --dbpath=/usr/local/mongodb/data/data1/ --logpath=/usr/local/mongodb/log/dblogs1 --fork 再启动一个实例 1# /usr/local/mongodb/bin/mongod --replSet rs1 --keyFile=/usr/local/mongodb/key/key2 --port 200002 --dbpath=/usr/local/mongodb/data/data2/ --logpath=/usr/local/mongodb/log/dblogs2 --fork 6、配置及初始化replica set（登录一台机器进行配置） 1# /usr/local/mongodb/bin/mongo --port 200001 进入后，直接配置（直接输入）即可config_rs1={ _id:”rs1”, members:[ {_id:0, host:”localhost:200001”, priority:1}, {_id:1, host:”localhost:200002”, priority:2} ]} 最后初始化配置rs.initiate(config_rs1); 这样就配置好了，端口号为200002的就相当于主服务器(因为优先级priority比较大)，端口号200001就是从服务器，主服务器可以就行增删改查数据，从服务器就只能查询数据 登录从服务器客户端输入命令，这样才有读的权限rs.slaveOk(); 扩展：查看副本集状态命令：rs.status(); 参考mongodb中文社区菜鸟教程]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>nosql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongodb数据库]]></title>
    <url>%2F2017%2F05%2F01%2Fmongodb%2F</url>
    <content type="text"><![CDATA[NoSQL数据库的优缺点优点：简单的扩展、快速的读写、低廉的成本、灵活的数据模型不足：不提供对SQL的支持、支持的特性不够丰富、现有的产品不够成熟 Mongodb特性mongodb的特点是高性能、易部署、易使用，存储数据非常方便，主要的特性有：面向集合存储，易于存储对象类型的数据模式自由支持动态查询支持完全索引，包含内部对象支持复制和故障恢复使用高效的二进制数据存储，包括大型对象（如视频等）自动处理碎片，以支持云计算层次的扩展性文件存储格式为BSON（一种JSON的扩展） mongobd体系结构逻辑结构关系对比关系型数据库：mysql数据库(database)、表(table)、记录(rows)三个层次概念组成非关系型数据库：mongodb数据库(database)、集合(collection)、文档对象(document)三个层次概念组成 mongodb的安装（安装较简单，不用源码编译安装，直接拷贝bin目录到你的安装目录即可）环境：Centos6.51、到mongodb官网下载对应的安装包2、解压压缩包 1# tar zxvf mongodb-linux-x86_64-amazon-3.4.4.tgz 3、拷贝bin目录到指定文件夹(我这里安装到/usr/local/mongodb) 12# cd mongodb-linux-x86_64-amazon-3.4.4/# rsync -a bin /usr/local/mongodb 4、进入到安装目录（/usr/local/mongodb），创建专门放置数据库的目录,记载日志文件 12345# cd /usr/local/mongodb///创建放置数据库的目录# mkdir data//创建记载日志文件# touch dblogs 至此mongodb已经安装完毕 扩展：mongodb开机自启动将mongodb启动项目加入rc.local保证mongodb在服务器开机时启动法1：vim /etc/rc.local加入/usr/local/mongodb/bin/mongod –dbpath=/usr/local/mongodb/data/ –logpath=/usr/local/mongodb/dblogs –fork 法2： 1# echo &quot;/usr/local/mongodb/bin/mongod --dbpath=/usr/local/mongodb/data/ --logpath=/usr/local/mongodb/dblogs --fork&quot; &gt;&gt; /etc/rc.local 启动mongodb1# /usr/local/mongodb/bin/mongod --dbpath=/usr/local/mongodb/data/ --logpath=/usr/local/mongodb/dblogs --fork 启动命令常用参数选项说明：–dbpath //指定数据库的目录–auth //用户验证–port //指定数据库的端口，默认是27017–bind_ip //绑定ip–directoryperdb //为每个bd创建一个独立子目录–logpath //指定日志存放目录–logappend //指定日志生成方式(追加/覆盖)–pidfilepath //指定进程文件路径，如果不知道，将不产生进程文件–keyFile //集群模式的关键标识–journal //启用日志–nssize //指定.ns文件的大小，单位MB，默认是16M，最大2GB–maxConns //最大的并发连接数–notablescan //不允许进行表扫描–noprealloc //关闭数据文件的预分配功能–fork //以后台Daemon形式运行服务更多参数选项利用mongod –help进行查看 关闭mongodb1234//法1# pkill mongod//法2# killall mongod 最好用上面两种的一种，如果用kill -9 进程id，会重启不了mongodb，需要到data目录下把锁文件(mongod.lock)删除掉，具体操作如下： 12# cd /usr/local/mongodb/data# rm -rf mongod.lock //把锁文件删除掉 用户授权（即登录需要用户名和密码）1、每个mongodb实例中的数据库都有许多用户，如果启用了安全性认证后，只有数据库认证的用户才可以进行读写操作。mongodb默认的启动是不验证用户名和密码的，启动mongodb后，可以直接用mongo连接上来，对所有的库具有root权限。所以启动的时候指定参数，可以阻止客户端的访问和连接，只需在启动服务时指定 –auth参数即可 1# /usr/local/mongodb/bin/mongod --dbpath=/usr/local/mongodb/data/ --auth --logpath=/usr/local/mongodb/dblogs --fork 2、现在还是可以通过/usr/local/mongodb/bin/mongo可以直接进入客户端操作的因为现在没有管理员帐号，mongodb分两种管理员，一种为超级管理员，一种为数据库管理员(即只对自己的数据库有权限) 2.1、先通过/usr/local/mongodb/bin/mongo进入到客户端创建帐号 2.2、创建超级管理员（一定要进入admin数据库创建才行）//先进入admin数据库use admin;//创建帐号root,密码为123db.addUser(“root”, “123”); 2.3、创建数据库管理员比如我需要为test数据库创建管理员，那我需要进入到test数据库先use test;db.addUser(“test”, “123”); 2.4测试登录创建好帐号后，退出客户端，再重新登录进入客户端exit;/usr/local/mongodb/bin/mongo -uroot -p123 localhost:27017/admin //超级管理员登录进入admin数据库 2.5总结超级管理员需要进入admin数据库进行创建，数据库管理员需要进入到对应的数据库进行创建。 参考mongodb中文社区菜鸟教程]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>nosql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql-主从复制]]></title>
    <url>%2F2017%2F03%2F20%2Fmysql-master-slave%2F</url>
    <content type="text"><![CDATA[mysql主从复制和慢查询日志说明 MySQL主从复制MySQL grant用户授权（先登录主服务器数据库进行用户授权）在主服务器设置授权用户（授权所有权限关于所有数据库中所有表，给user这个用户从主机为192.168.10.2登录，密码为123456）1234567//方法1：mysql&gt; grant all on *.* to user@192.168.10.2 identified by &apos;123456&apos;;//方法2：mysql&gt; grant replication slave on *.* to user@192.168.10.2 identified by &apos;123456&apos;;//查看用户授权表（即mysql数据库中的user表）mysql&gt; select user,host,password from mysql.user; 修改主数据库服务器的配置文件my.cnf，开启big-log日志，并设置server-id的值log-bin=mysql-binserver-id=1 备份主服务器的数据库1234//清除bin-log日志mysql&gt; reset master;//备份数据库mysql&gt; /usr/local/mysql/bin/mysqldump -uroot -p123456 test -l -F &gt; /tmp/test.sql 同步从服务器上的数据12//先从主服务器复制一份test.sql到从服务器(192.168.10.2)下的tmp目录[root@localhost]# scp /tmp/test.sql 192.168.10.2:/tmp/ 123456//登录从服务器数据库mysql&gt; /usr/local/mysql/bin/mysql -uroot -p123456 test//清空所有的big-log日志mysql&gt; reset master;//进行导入同步数据mysql&gt; /usr/local/mysql/bin/mysql -uroot -p123456 test &lt; /tmp/test.sql 配置从服务器的配置文件my.cnflog-bin=mysql-binserver-id=2master-host=192.168.10.1master-user=usermaster-password=123456master-port=3306 重启从服务器mysql(先关闭mysql，再重启mysql)123456789//关闭方法1pkill mysqld//关闭方法2ps -aux | grep mysql //先查看进程pidkill -15 pid //正常关闭//重启mysql/usr/local/mysql/bin/mysqld_safe --user=mysql &amp; 查看从服务器是否已经同步了（查看相应的主从复制进程列表）方法1：1mysql&gt; show slave status\G 如下图所示：Slave_IO_Running:Yes //此进程负责读取主服务器上的big-log日志，并且写入到从服务器上的big-log日志Slave_SQL_Running:Yes //此进程负责读取并且执行big-log日志表示已经同步了（注意：以上两个都为Yes则表示成功，否则失败，错误原因可以从”last_error”字段的值中看到） 方法2：1mysql&gt; show processlist\G 如下图所示：state:waiting for master to send event //表示连接主数据库为成功，而且成功获取big-logstate:has read all ready log;waiting for the slave i/o thread to update it //表示成功执行big-log日志，正在等待着再次连接主数据库并更新获取big-log日志表示已经同步了 扩展从数据库常用命令：12345mysql&gt; start slave; //启动复制进程mysql&gt; stop slave; //停止复制进程mysql&gt; show slave status; //查看数据库状态mysql&gt; change master to //动态改变服务器的配置mysql&gt; show processlist //查看数据库运行进程 从数据库无法同步：Show slave status显示slave_sql_running为No,seconds_behind_master为null原因：1、程序可能在slave上进行了写操作2、也可能是slave机器(从服务器)重启后，事务回滚造成的 解决方法1：123mysql&gt; slave stop;mysql&gt; set GLOBAL SQL_SLAVE_SKIP_COUNTER=1;mysql&gt; slave start; 解决方法2：停止从服务器复制进程1mysql&gt; slave stop; 查看主服务器当前的bin-log日志名和偏移量1mysql&gt; show master status; //下一步需要用到日志名称和偏移量 如图所示 最后到slave(从)服务器上执行手动同步123456789101112mysql&gt; change master tomaster_host=&quot;192.168.10.1&quot;,master_user=&quot;user&quot;,master_password=&quot;123456&quot;,master_port=3306,master_log_file=&quot;mysql-bin.000003&quot;, //对应上一步的日志名称master_log_pos=98; //对应上一步的偏移量//启动slave(复制进程)mysql&gt; slave start;//最后再查看数据库状态mysql&gt; show slave status\G MYSQL bin-log日志开启MYSQL bin-log日志vim /etc/my.cnf[mysqld]….log-bin=mysql-bin bin-log日志相关mysql指令可以查看是否开启bin-log日志1mysql&gt; show variables like &quot;%bin%&quot;; 生成一个最新的bin-log日志1mysql&gt; flush logs; 查看big-log日志1mysql&gt; show binary logs; 查看最后一个big-log日志1mysql&gt; show master status; 清空所有的big-log日志1mysql&gt; reset master; 使用mysqlbiglog来查看big-log日志（打开mysql-bin.000002日志）1[root@localhost]# /usr/local/mysql/bin/mysqlbinlog --no-defaults mysql-bin.000002 如果不加参数–no-defaults会报错，报错内容是说字符集有问题 mysql备份和bin-log日志结合使用例子： 1、对test数据库进行备份数据，备份完成的同时生成一个新的log-bin日志文件：1[root@localhost]# /usr/local/mysql/bin/mysqldump -uroot -p123456 test -l -F &gt; /tmp/test.sql 参数说明：-l为读锁(备份期间所有人都不能进行写的操作，但是可以进行读的操作)、-F(即相当于执行了flush logs指令),可以重新生成新的日志文件，其中包括log-bin日志 2、在备份完成后又添加了一些数据123mysql&gt; insert into t1 values(3);mysql&gt; insert into t1 values(4);mysql&gt; insert into t1 values(5); 3、此时突然数据库损坏或者人为删除模拟人为删除表1mysql&gt; drop table t1; 如何恢复数据？步骤一，先用已经备份的t1.sql来恢复数据12[root@localhost]# /usr/local/mysql/bin/mysql -uroot -p123456 test -f &lt; /tmp/test.sql参数-f(可选参数)表示当遇到错误时，可以skip过去，继续执行下面的语句 但是自从上次备份后添加或者修改的数据会丢失，怎么办？只能用big-log来恢复 先查看最后生成的big-log日志1[root@localhost]# /usr/local/mysql/bin/mysqlbinlog --no-defaults mysql-bin.000005 | more 截图如下： 找到对应的sql语句对应的end_log_post id开始用big-log来恢复备份后添加或者修改的数据1[root@localhost]# /usr/local/mysql/bin/mysqlbinlog --no-defaults --stop-position='666' mysql-bin.000005 | /usr/local/mysql/bin/mysql -uroot -p123456 test mysqlbinlog可选参数说明：–start-position=’20’–stop-position=’111’–start-date=’2017-01-18 00:00:00’–stop-date=’2017-01-18 23:59:59’]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql-分区技术]]></title>
    <url>%2F2017%2F03%2F16%2Fmysql-partition%2F</url>
    <content type="text"><![CDATA[mysql-分区技术 MYSQL分区技术MYSQL的分区技术与水平分表有点类似，但是它是在逻辑层进行的水平分表，对于应用程序而言它还是一张表。MYSQL5.1有5种分区类型：RANGE分区：基于属于一个给定连续区间的列值，把多行分配给分区LIST分区：类似于RANGE分区，区别在于LIST分区是基于列值分配一个离散集合中的某个值来进行选择HASH分区：。。。KEY分区：。。。 例子1：假定你创建了一个如下的表，该表保存有20家音像店的职员记录，这20家音像店的编号从1到20.如果你想将其分成4个小分区，那么你可以采用RANGE分区，创建的数据库表如下：123456789101112131415mysql&gt; CREATE TABLE employees( id INT NOT NULL, fname VARCHAR(30), iname VARCHAR(30), hired DATE NOT NULL DEFAULT &apos;1970-01-01&apos;, separated DATE NOT NULL DEFAULT &apos;9999-12-31&apos;, job_code INT NOT NULL, store_id INT NOT NULL)engine=myisam default charset=utf8PARTITION BY RANGE(store_id)( PARTITION p0 VALUES LESS THAN(6), PARTITION p1 VALUES LESS THAN(11), PARTITION p2 VALUES LESS THAN(16), PARTITION p3 VALUES LESS THAN(21)); 例子2：假定你创建了一个如下的表，该表保存有20家音像店的职员记录，这20家音像店的编号从1到20。如果你想把不同时期离职的员工进行分别存储，那么你可以将日期字段separated(即离职时间)作为一个key，创建的数据库表如下：123456789101112131415mysql&gt; CREATE TABLE employees1( id INT NOT NULL, fname VARCHAR(30), iname VARCHAR(30), hired DATE NOT NULL DEFAULT &apos;1970-01-01&apos;, separated DATE NOT NULL DEFAULT &apos;9999-12-31&apos;, job_code INT NOT NULL, store_id INT NOT NULL)PARTITION BY RANGE(YEAR(separated))( PARTITION p0 VALUES LESS THAN(1991), PARTITION p1 VALUES LESS THAN(1996), PARTITION p2 VALUES LESS THAN(2001), PARTITION p3 VALUES LESS THAN MAXVALUE); 说明：YEAR()是mysql的一个日期函数，将日期类型的字段转换为整数类型，从而就可以作为RANGE分区的key。 条件(range、list)分区算法管理增加分区： alter table 表名 add partition( partition 分区名 values less than[in] (常量[列表]), partition 分区名 values less than[in] (常量[列表]), …. )减少分区： alter table 表名 drop partition 分区名称; 减少分区，会丢失对应分区的数据。 例如：1234mysql&gt; alter table employees1 add partition( partition p4 values less than (2008), partition p4 values less than (2009)); innodb表数据结构对于innodb表的数据结构，首先要解决两个概念性的问题：共享表空间以及独占表空间。共享表空间以及独占表空间都是针对数据的存储方式而言的。共享表空间：某一个数据库的所有的表数据、索引文件全部放在一个文件中，默认这个共享表空间的文件路径在data目录下，默认的文件名为：ibdata1，初始化大小为10M。独立表空间：每一个表都将会生成以独立的文件方式来进行存储，每一个表都有一个。frm表描述文件，还有一个.ibd文件。其中这个文件包括了单独一个表的数据内容以及索引内容，默认情况下他的存储位置也是在表的位置之中 查看innodb表空间设置12//为on表示是独立表空间，off表示共享表空间mysql&gt; show variables like &apos;innodb_file_per_table&apos;; 如何修改innodb表为独立表空间配置mysql的配置文件my.cnf…innodb_data_home_dir=”C:\mysql\data\” //默认存在的，只需把前面井号去掉即可innodb_log_group_home_dir=”C:\mysql\data\” //默认存在的，只需把前面井号去掉即可innodb_data_file_path=ibdata1:10M:autoextend //默认存在的，只需把前面井号去掉即可innodb_file_per_table=1 参数说明：这些设置表示配置一个可扩展大小的尺寸为10MB的单独文件，名为ibdata1,没有给出文件的位置，所以默认的是在mysql的数据目录内。innodb_data_home_dir //代表为数据库文件所存放的目录innodb_log_group_home_dir //为日志存放目录innodb_file_per_table //是否使用共享以及独立表空间来以上的几个参数必须在一起加入 把共享表空间的表转移到独立表空间步骤：1、使用mysqldump导出所有数据库表数据2、停止mysql服务，修改参数（修改为独立表空间），并删除原先innodb共享表相关文件3、重启mysql服务4、重新导入数据 说明：1、只有把innodb设置成独立表空间后，才能创建成功innodb表引擎的表分区2、mysql5.6之后版本默认配置是独立表空间]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql-SQL语句技巧和优化]]></title>
    <url>%2F2017%2F03%2F13%2Fmysql-optimize%2F</url>
    <content type="text"><![CDATA[SQL语句技巧和优化 mysql SQL语句技巧和优化mysql5.5及之后版本默认存储引擎是innodb 巧用RAND()提取随机行rand()是获取一个0-1之间的随机数1select * from st_vonfly order by rand(); 随机抽取3条数据样本1select * from st_vonfly order by rand() limit 3; 优化group by语句有的sql语句在执行的时候，本身默认会有排序效果但是有的时候我们的业务不需要排序效果，就可以进行强制限制，进而“节省默认排序”的资源。 如果查询包含group by但用户想要避免排序结果的损耗，则可以使用order by null来禁止排序： 优化嵌套查询表1如图：CREATE TABLE tp_user ( id int(10) unsigned NOT NULL AUTO_INCREMENT, name varchar(16) NOT NULL, parents_id int(10) NOT NULL, PRIMARY KEY (id)) ENGINE=MyISAM DEFAULT CHARSET=utf8表2如图：CREATE TABLE tp_parents ( id int(10) unsigned NOT NULL AUTO_INCREMENT, parent_name varchar(16) NOT NULL, PRIMARY KEY (id)) ENGINE=MyISAM DEFAULT CHARSET=utf8 下面是采用嵌套查询的效果（可以使用更有效的连接查询(JOIN)替代） mysql&gt; desc select from tp_parents where id in(select parents_id from tp_user)\G** 1. row *** id: 1 select_type: PRIMARY table: tp_parents type: ALLpossible_keys: NULL key: NULL key_len: NULL ref: NULL rows: 3 Extra: Using where*** 2. row *** id: 2 select_type: DEPENDENT SUBQUERY table: tp_user type: ALLpossible_keys: NULL key: NULL key_len: NULL ref: NULL rows: 4 Extra: Using where2 rows in set (0.06 sec) 数据库优化优化表的类型通过拆分提高表的访问效率使用中间表提高统计查询速度 MYSQL服务器优化四种字符集问题(统一设置为utf8)1mysql&gt; \s 如何设置？vim /etc/my.cnf[client] #password=your_passwordport=3306socket=/tmp/mysql.sockdefault-character-set=utf8 //控制的是客户端字符集和连接字符集 [mysqld]…….myisam_sort_buffer_size=8Mcharacter-set-server=utf8 //控制服务器字符集和数据库字符集collation-server=utf8_general_ci //校验字符集，主要针对的排序 查看中文字符集以及对应的校验字符集1mysql&gt; show character set; 如图所示： bin log日志问题slow log慢查询日志问题可以查看是否开启慢查询日志1mysql&gt; show variables like &quot;%slow%&quot;; 设置的慢查询时间1mysql&gt; show variables like &quot;%long%&quot;; 开启慢查询日志和设置慢查询时间：vim /etc/my.cnf[mysqld]…….log_slow_queries=slow.loglong_query_time=5 socket问题mysql socket无法登录1.有时登录mysql时提示不能用socket登录，此时可以换成tcp方式去登录，但是只有测试时可以这样用，必须要在php去用之前把这个事情解决了 1# mysql -uroot -p123456 --protocol tcp -hlocalhost 这样就可以登录，就不用mysql.socket来登录。把mysql重新启动就会自动生成socket文件 root密码丢失root密码丢失破解步骤1.service mysqld stop //把mysql关闭2.mysqld_safe –skip-grant-tables –user=mysql &amp; //跳过授权表mysql.user和mysql.db来重启mysql3.mysql -uroot; //登录进mysql4.1mysql&gt; update mysql.user set password=password(&quot;123456&quot;) where user=&quot;root&quot; and host=&quot;localhost&quot;; SQL语句的优化步骤一、通过慢查询日志查看效率低的sql语句二、通过explain或者desc解析sql语句(查看是否需要做索引)12explain select * from table where id = 8\Gdesc select * from table where id = 8\G 每一列的简单解释id:1select_type:SIMPLE //表示select的类型，常见的取值有SIMPLE(简单表，即不使用表连接或者子查询)、PRIMARY(主查询，即外层的查询)、UNION(UNION中的第二个或者后面的查询语句)、SUBQUERY(子查询中的第一个SELECT)等table:stu //输出结果集的表type:range //表示表的连接类型，性能由好到查：system(表仅一行)、const(只一行匹配)、eq_ref(对于前面的每一行使用主键和唯一)、ref(同eq_ref，但没有使用主键和唯一索引)、ref_or_null(同前面，对null查询)、index_merge(索引合并优化)、unique_subquery(主键子查询)、index_subquery(非主键子查询)、range(表单中的范围查询)、index(都通过查询索引来得到数据)、all(通过全表扫描得到的数据)possible_keys:name,ind_stu_name //表查询时可能使用的索引key:name //表示实际使用的索引key_len:50 //索引字段的长度ref:NULLrows:8 //扫描行的数量Extra:Using where;Using index //执行情况的说明和描述 总结：where 和 order by后边的条件字段都可以适当设置索引、分组字段也可以添加索引，避免产生临时表 对表的优化和检测检查一个或多个表是否有错误语法如下：1mysql&gt; CHECK TABLE tb1_name[,tb1_name]...[option]... option=&#123;QUICK|FAST|MEDIUM|EXTENDED|CHANGED&#125; 例子（检查a1表是否有错误）：1mysql&gt; check table a1; 对损坏或错误的表进行修复语法如下：1mysql&gt; repair TABLE tb1_name[,tb1_name]...[option]... 例子（修复a1表）：1mysql&gt; repair table a1; 定期优化表（找访问较少的时间进行优化，防止影响业务）如果已经删除了表的一大部分，或者如果已经对含有可变长度行的表进行了很多的改动，则需要做定期优化。这个命令(optimize)可以将表中的空间碎片进行合并，但是此命令只对myisam、BDB和innobd表起作用。 语法：1mysql&gt; OPTIMIZE [LOCAL|NO_WRITE_TO_BINLOG] TABLE tb1_name [,tb1_name] 例子(对a1表进行优化)：1mysql&gt; optimize table a1; 字段类型选择原则：当一个列可以选择多种数据类型时，应该优先考虑数字类型，其次是日期或者二进制类型，最后是字符类型。对于相同级别的数据类型，应该优先选择占用空间小的数据类型。 信息最好存储为整型的(mysql运行速度快，运算速度快)时间信息可以存储为整型的(时间戳)，用int类型select from_unixstamp(时间戳) from 表名 set集合类型 多选：set(‘篮球’,’足球’,’棒球’,’乒乓球’);enum枚举类型 单选： enum(‘男’,’女’,’保密’);推荐使用set和enum类型，内部会通过整型信息参数具体计算、运行。 ip地址也可以变为整型信息进行存储(mysql内部有算法，把ip变为数字)：mysql： inet_aton(ip) inet_ntoa(数字)php: ip2long(ip) long2ip(数字) 尽量少的占据存储空间tinyint : 0~255 1字节smallint : 0~ 65535 2字节mediumint : 0~1千6百多万 3字节int : 0~40多亿 4字节 数据的整合最好固定长度char :0~255个字符varchar : 0~65535 字节 看表编码，如果是utf8存2万多汉字 gbk存3万多汉字 char(长度)固定长度，运行速度快长度：255字符限制varchar(长度)长度不固定，内容比较少要进行部位操作，该类型要保留1-2个字节保存当前数据的长度长度：65535字节限制 存储汉字，例如字符集utf8的(每个汉字占据3个字节)，最多可以存储65535/3-2字节 例如字符集gbk的(每个汉字占据2个字节)，最多可以存储65535/2-2字节 如存储手机号码：char(11) ，可以选取固定长度的]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql简单操作]]></title>
    <url>%2F2017%2F03%2F08%2Fmysql-commands%2F</url>
    <content type="text"><![CDATA[常用的一些mysql操作（mysql高性能优化、mysql深入浅出） mysql具体语法帮助123456mysql&gt; ? contents //查看所有帮助大纲，然后通过帮助大纲再用?继续往下查询具体语法mysql&gt; ? index //查看索引具体操作帮助信息mysql&gt; ? view //查看视图具体操作帮助信息mysql&gt; ? create view //创建视图具体操作帮助信息mysql&gt; ? reg% //如果记不住全称，可以使用%来代替 结果进行行列颠倒（\G）12mysql&gt; show plugins;mysql&gt; show plugins\G mysql表复制（包括复制表结构和表数据）12mysql&gt; create table vf_a2 like vf_a1; //先复制表结构mysql&gt; insert into vf_a2 select * from vf_a1; //复制表数据。说明：表vf_a1和表vf_a2字段完全一样的前提下用*，否则要复制某些字段要具体写字段 表名修改12//把表名为t2修改为t1mysql&gt; rename table t2 to t1; 添加、修改字段12345678910//添加字段usernamemysql&gt; alter table vf_a1 add username varchar(32) not null default &apos;&apos; comment &apos;用户名&apos;;//修改字段mysql&gt; alter table vf_a1 modify username varchar(20) not null default &apos;&apos; comment &apos;用户名&apos;;//修改字段mysql&gt; alter table vf_a1 change username varchar(20) not null default &apos;&apos; comment &apos;用户名&apos;;//删除username字段mysql&gt; alter table vf_a1 drop username; 索引的创建、删除、查看方法一： create index（创建索引）、drop index（删除索引）12345mysql&gt; create index in_name on vf_a1(name); //为表vf_a1的name字段创建普通索引mysql&gt; create unique index un_name on vf_a1(name); //为表vf_a1的name字段创建唯一索引mysql&gt; drop index in_name on vf_a1; //删除表vf_a1名称为in_name的索引 方法二（常用以及全面的方法，可以创建普通索引、唯一(unique)索引和主键(primary key)索引）：1234567891011121314151617mysql&gt; alter table vf_a1 add index in_name(name); //为表vf_a1的name字段创建普通索引mysql&gt; alter table vf_a1 add unique in_name(name); //为表vf_a1的name字段创建唯一索引mysql&gt; alter table vf_a1 drop index in_name; //删除表vf_a1名称为in_name的索引//删除主键索引（先删除主键字段的自增，然后再删除主键索引）mysql&gt; id int unsigned not null auto_increment //原来字段mysql&gt; alter table vf_a1 modify id int unsigned not null; //修改字段（不写auto_increment就是把auto_increment(自增)删除了）mysql&gt; alter table vf_a1 drop primary key; //再删除主键索引//增加主键索引(先添加主键索引，再修改主键字段为自增)mysql&gt; alter table vf_a1 add primary key(id);mysql&gt; id int unsigned not null; //原来字段mysql&gt; alter table vf_a1 modify id int unsigned not null auto_increment; //修改主键字段为自增 查看索引1mysql&gt; show index from vf_a1; //查看表vf_a1下的索引 mysql视图（中间表，把满足条件的记录生成一张中间表，就可以直接对这张表进行增删改查，提高性能）创建视图1mysql&gt; create view v_a1 as select * from a1 where id&gt;8; 查看视图（即查看表）1mysql&gt; show tables; 删除视图1mysql&gt; drop view v_a1; //删除名称为v_a1的视图 mysql存储需求：向表a1（有主键id和name两个字段）插入一百条数据，字段name的值依次为user1、user2、user3…..user100 先修改定界符，因为mysql存储很多语句都是以分号结束的1mysql&gt; \d // //把语句定界符分号修改为// 再创建存储12345678mysql&gt; create procedure p1() -&gt; begin -&gt; set @i=1; -&gt; while @i&lt;=100 do -&gt; insert into a1(name) values(concat(&quot;user&quot;, @i)); -&gt; set @i=@i+1; -&gt; end while; -&gt; end// 最后执行刚刚创建的存储p1123mysql&gt; call p1;mysql&gt; select * from a1; //查看数据是否创建成功 查看mysql存储123mysql&gt; show procedure status; //查看存储状态mysql&gt; show create procedure p1; //查看存储p1的具体信息 mysql事务处理(innodb表引擎才支持)12//关闭自动提交功能mysql&gt; set autocommit=0; 12//从表a1中删除了一条记录mysql&gt; delete from a1 where id=11; 12//此时做一个p1还原点mysql&gt; savepoint p1; 12//再次从表a1中删除了一条记录mysql&gt; delete from a1 where id=12; 12//再次做一个p2还原点mysql&gt; savepoint p2; 12//此时恢复到p1还原点，当然后面的p2这些还原点自动会失效mysql&gt; rollback to p1; 12//如果退回到最原始的还原点mysql&gt; rollback; 清空表(清空内容以及auto_increment恢复成1开始)1mysql&gt; truncate table tablename; mysql变量使用（需要查些资料多学习下,如mysql手册）1、需求：查询排名create table vo_students( id int unsigned not null auto_increment, name varchar(30) not null default ‘’ comment ‘名字’, score smallint not null default 0 comment ‘分数’, primary key (id))engine myisam default charset utf8;insert into vo_students(name, score) values (‘zhang’, 100),(‘li’, 89),(‘sun’, 57),(‘zhao’, 100),(‘zhou’, 89),(‘qian’, 92); 具体方法：set @pres:=0,@currs:=0,@rank:=0;select name,(@currs:=score) as score, @rank:=if(@currs&lt;&gt;@pres,@rank:=@rank+1,@rank) as rank,@pres:=score as prev from vo_students order by score desc; mysql内置函数——————————————————————- 字符串函数： CONCAT(string2 [,….]) //连接字符串1select concat(&quot;hello &quot;, &quot;world&quot;); LCASE(sting2) //转换成小写UCASE(sting2) //转换成大写 LENGTH(string2) //string2的长度1select length(&quot;vonfly&quot;); LTRIM(string2) //去除左边空格RTRIM(string2) //去除右边空格 REPEAT(string2,count) //重复count次1select repeat(&quot;vonfly&quot;, 6); REPLACE(string2, search_str, replace_str) //在string2中用replace_str替换search_str1select replace(&quot;vonfly is my web&quot;, &quot;my&quot;, &quot;your&quot;); SUBSTR(string2, position [,length]) //从string2的position开始，取length个字符1select substr(&quot;vonfly is my web&quot;, 1, 5); SPACE(count) //生成count个空格 日期函数CURDATE() //返回当前日期CURTIME() //返回当前时间NOW() //返回当前的日期时间UNLX_TIMESTAMP(date) //返回当前date的UNIX时间戳FROM_UNIXTIME() //返回UNLX时间戳的日期值YEAR(date) //返回日期date的年份DATEDIFF(expr1,expr2) //返回起始时间expr1和结束时间expr2的天数]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些PHP方法]]></title>
    <url>%2F2017%2F02%2F28%2Fphp-knowledge1%2F</url>
    <content type="text"><![CDATA[主要用于自己学习(●’◡’●) 用最少的代码写一个求3值最大值的函数123function($a,$b,$c)&#123; return $a &gt; $b ? ($a &gt; $c ? $a : $c) : ($b &gt; $c ? $b : $c);&#125; 用PHP打印出前一天的时间，打印格式是2007年5月10日22:21:211echo date('Y-m-d H:i:s', strtotime('-1 day')); 输出正在浏览当前页面用户的IP地址1echo $_SERVER["REMOTE_ADDR"]; 查询（query）的字符串URL中第一个问号 ? 之后的内容（比如http://localhost/text.php?id=1&amp;bi=2，查询出 id=1&amp;bi=2 ）1echo $_SERVER["QUERY_STRING"]; 当前运行脚本所在的文档根目录1echo $_SERVER["DOCUMENT_ROOT"]; 写一个函数，能够遍历一个文件夹下的所有文件和子文件夹123456789101112131415161718192021222324252627function my_scandir($dir)&#123; $files=array(); if(is_dir($dir)) &#123; if($handle=opendir($dir)) &#123; while(($file=readdir($handle))!==false) &#123; if($file!="." &amp;&amp; $file!="..") &#123; if(is_dir($dir."/".$file)) &#123; $files[$file]=my_scandir($dir."/".$file); &#125; else &#123; $files[]=$dir."/".$file; &#125; &#125; &#125; closedir($handle); return $files; &#125; &#125;&#125;var_dump(my_scandir("F:ali")); 请用正则表达式（Regular Expression）验证电子邮件的格式是否正确。123456789$email = '1185236@163.com';if( !preg_match('/^[\w.]+@([\w.]+)\.[a-z]&#123;2,6&#125;$/i', $email) )&#123; echo "电子邮件格式不正确！";&#125;else&#123; echo "电子邮件格式正确！";&#125; 写出匹配URL的正则表达式./^http:\/\/www.([\w]+).([\w]+)$/ 用PHP写出显示客户端IP与服务器IP的代码12echo $_SERVER["REMOTE_ADDR"]; //客户端IPecho gethostbyname("www.baidu.com"); //服务器IP 如何修改SESSION的生存时间方法1：将php.ini中的session.gc_maxlifetime设置为9999重启apache 方法2：在当前项目中修改123$expire = 3600 * 3;ini_set('session.gc_maxlifetime', $expire);ini_set('session.cookie_lifetime', $expire); 有一个网页地址, 比如百度主页: http://www.baidu.com/,如何得到它的内容?方法1：1234$readcontents = fopen("http://www.baidu.com/", "rb");$contents = stream_get_contents($readcontents);fclose($readcontents);echo $contents; 方法2：12$readcontents = file_get_contents("http://www.baidu.com/");echo $readcontents; 写一个函数，尽可能高效的，从一个标准 url 里取出文件的扩展名例如: http://www.sina.com.cn/abc/de/fg.php?id=1 需要取出 php 或 .php方法1：1234567function getExt($url)&#123; $arr = parse_url($url); $file = basename($arr['path']); $ext = explode(".", $file); return $ext[1];&#125;echo getExt('http://www.sina.com.cn/abc/de/fg.php?id=1'); 方法2：123456789101112function getExt($url) &#123; $url = basename($url); $pos1 = strpos($url, "."); $pos2 = strpos($url, "?"); $length = $pos2 - $pos1 - 1; if(strstr($url, "?"))&#123; return substr($url, $pos1 + 1, $length); &#125; else &#123; return substr($url, $pos1); &#125;&#125;echo getExt('http://www.sina.com.cn/abc/de/fg.php?id=1'); 使用五种以上方式获取一个文件的扩展名要求：dir/upload.image.jpg，找出 .jpg 或者 jpg ，必须使用PHP自带的处理函数进行处理，方法不能明显重复，可以封装成函数，比如 get_ext1($file_name), get_ext2($file_name) 12345$file_name = 'dir/upload.image.jpg';function get_ext1($file_name)&#123; return strrchr($file_name, '.');&#125;echo get_ext1($file_name); 12345$file_name = 'dir/upload.image.jpg';function get_ext2($file_name)&#123; return substr( $file_name, strrpos($file_name, '.') );&#125;echo get_ext2($file_name); 1234567$file_name = 'dir/upload/image.jpg';function get_ext3($file_name)&#123; $stack = explode('.', $file_name); $fruit = array_pop($stack); return $fruit;&#125;echo get_ext3($file_name); 123456$file_name = 'dir/upload/image.jpg';function get_ext4($file_name)&#123; $p = pathinfo($file_name); return $p['extension'];&#125;echo get_ext4($file_name); 1234567$file_name = 'dir/upload/image.jpg';function get_ext5($file_name)&#123;return strrev(substr(strrev($file_name), 0, strpos(strrev($file_name), '.')));&#125;echo get_ext5($file_name); 输出以下值1234567891011121314$str1 = null;$str2 = false;echo $str1==$str2 ? '相等' : '不相等';//输出相等$str3 = '';$str4 = 0;echo $str3==$str4 ? '相等' : '不相等';//输出相等$str5 = 0;$str6 = '0';echo $str5===$str6 ? '相等' : '不相等';//输出不相等 求两个日期的差数，例如2007-2-5 ~ 2007-3-6 的日期差数1234567function get_days($date1, $date2)&#123; $time1 = strtotime($date1); $time2 = strtotime($date2); return abs($time2-$time1)/86400;&#125;echo get_days('2007-2-5', '2007-2-6'); 请写一个函数，实现以下功能：字符串”open_door” 转换成 “OpenDoor”、”make_by_id” 转换成 “MakeById”方法一：1234567function str_explode($str)&#123; $str_arr=explode("_",$str); $str_implode=implode(" ", $str_arr); $str_implode=implode("", explode(" ",ucwords($str_implode))); return $str_implode;&#125;echo str_explode('open_door'); 方法二：123456$str = 'open_door';$expStr = explode("_", $str);for($i = 0; $i &lt; count($expStr); $i++)&#123; echo ucwords($expStr[$i]);&#125; 方法三：1echo str_replace(' ', '', ucwords( str_replace('_', ' ', 'open_door') ) ); echo count(“abc”); 输出什么?答案：1说明：count — 计算数组中的单元数目或对象中的属性个数int count ( mixed$var [, int $mode ] ), 如果 var 不是数组类型或者实现了 Countable 接口的对象，将返回1，有一个例外，如果 var 是 NULL 则结果是 0。 对于对象，如果安装了 SPL，可以通过实现 Countable 接口来调用 count()。该接口只有一个方法 count()，此方法返回 count() 函数的返回值。 有一个一维数组，里面存储整形数据，请写一个函数，将他们按从大到小的顺序排列。要求执行效率高。并说明如何改善执行效率。（该函数必须自己实现，不能使用php函数）1234567891011121314151617181920212223242526function BubbleSort(&amp;$arr)&#123; $cnt = count($arr); $flag = 1; for($i = 0; $i &lt; $cnt; $i++) &#123; if($flag == 0) &#123; return; &#125; $flag = 0; for($j = 0;$j &lt; $cnt-$i-1; $j++) &#123; if($arr[$j] &gt; $arr[$j+1]) &#123; $tmp = $arr[$j]; $arr[$j] = $arr[$j+1]; $arr[$j+1] = $tmp; $flag = 1; &#125; &#125; &#125;&#125;$test=array(1,3,6,8,2,7);BubbleSort($test);var_dump($test); 写一个函数实现字符串翻转方法一：strrev(‘abcdef’);方法二：12345678910function str($a)&#123; $len = strlen($a); $b = ""; for($i = $len-1; $i &gt;= 0; $i--) &#123; $b .= $a[$i]; &#125; return $b;&#125;echo str('abcdef'); 不断在文件hello.txt头部写入一行“Hello World”字符串，要求代码完整1234567891011$fp=fopen('hello.txt', 'r');$str='hello!'."\n";$str.=fread($fp, filesize('./hello.txt'));fclose($fp);$fp1=fopen('hello.txt', 'w');fwrite($fp1, $str);]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[收集、总结的一些PHP理论知识（对于面试有帮助）]]></title>
    <url>%2F2017%2F02%2F28%2Fphp-knowledge%2F</url>
    <content type="text"><![CDATA[本页面主要用于编写一些理论知识，从网上找的或者自己总结的都会有。主要用于自己学习(●’◡’●) 简述 private、 protected、 public修饰符的访问权限private: 私有成员, 在类的内部才可以访问 protected: 保护成员，该类内部和继承类中可以访问 public: 公共成员，完全公开，没有访问限制 面向对象的特征有哪些方面?主要有封装,继承,多态。如果是4个方面则加上：抽象。 理解： 1、封装：封装是保证软件部件具有优良的模块性的基础,封装的目标就是要实现软件部件的高内聚,低耦合,防止程序相互依赖性而带来的变动影响 2、继承：在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并可以加入若干新的内容，或修改原来的方法使之更适合特殊的需要，这就是继承。继承是子类自动共享父类数据和方法的机制，这是类之间的一种关系，提高了软件的可重用性和可扩展性 3、多态：多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。 4、抽象：抽象就是找出一些事物的相似和共性之处，然后将这些事物归为一个类，这个类只考虑这些事物的相似和共性之处，并且会忽略与当前主题和目标无关的那些方面，将注意力集中在与当前目标有关的方面。例如，看到一只蚂蚁和大象，你能够想象出它们的相同之处，那就是抽象。 常见的 PHP 安全性攻击1、SQL注入：用户利用在表单字段输入SQL语句的方式来影响正常的SQL执行。 防止：(1)使用mysql_real_escape_string()过滤数据(2)手动检查每一数据是否为正确的数据类型(3)使用预处理语句并绑定变量(4)参数化SQL：是指在设计与数据库链接并访问数据时，在需要填入数值或数据的地方，使用参数 (Parameter) 来给值，用@或？来表示参数。 2、XSS攻击 ：跨站点脚本攻击，由用户输入一些数据到你的网站，其中包括客户端脚本(通常JavaScript)。如果你没有过滤就输出数据到另一个web页面，这个脚本将被执行。 防止：为了防止XSS攻击，使用PHP的htmlentities()函数过滤再输出到浏览器。 抽象类和接口的概念以及区别？1、抽象类：它是一种特殊的，不能被实例化的类，只能作为其他类的父类使用。使用abstract关键字声明。2、接口是一种特殊的抽象类，也是一个特殊的类，使用interface声明 区别：（1）抽象类的操作通过继承关键字extends实现，而接口的使用是通过implements关键字来实现。 （2）抽象类中有数据成员，可以实现数据的封装，但是接口没有数据成员。 （3）抽象类中可以有构造方法，但是接口没有构造方法。 （4）抽象类的方法可以通过private、protected、public关键字修饰（抽象方法不能是private），而接口中的方法只能使用public关键字修饰。 （5）一个类只能继承于一个抽象类，而一个类可以同时实现多个接口。 （6）抽象类中可以有成员方法的实现代码，而接口中不可以有成员方法的实现代码。 什么是构造函数，什么是析构函数，作用是什么？1、构造函数（方法）是对象创建完成后第一个被对象自动调用的方法。它存在于每个声明的类中，是一个特殊的成员方法。作用是执行一些初始化的任务。Php中使用__construct()声明构造方法，并且只能声明一个 2、析构函数（方法）作用和构造方法正好相反，是对象被销毁之前最后一个被对象自动调用的方法。是PHP5中新添加的内容作用是用于实现在销毁一个对象之前执行一些特定的操作，诸如关闭文件和释放内存等。 如何重载父类的方法，举例说明1、重载，即覆盖父类的方法，也就是使用子类中的方法替换从父类中继承的方法，也叫方法的重写。 2、覆盖父类方法的关键是在子类中创建于父类中相同的方法包括方法的名称、参数和返回值类型。PHP中只要求方法的名称相同即可。 $this和self、parent这三个关键词分别代表什么？在哪些场合下使用？1、$this 当前对象 2、self 当前类 3、parent 当前类的父类 使用场合： $this在当前类中使用,使用-&gt;调用属性和方法。 self也在当前类中使用，不过需要使用::调用。 parent在类中使用。 类中如何定义常量、如何类中调用常量、如何在类外调用常量。1、类中的常量也就是成员常量，常量就是不会改变的量，是一个恒值。 2、定义常量使用关键字const 例如：const PI = 3.1415326; 如何调用： 无论是类内还是类外，常量的访问和变量是不一样的，常量不需要实例化对象，访问常量的格式都是类名加作用域操作符号（双冒号）来调用。即：类名 :: 类常量名; 堆和栈的区别？1、栈是编译期间就分配好的内存空间，因此你的代码中必须就栈的大小有明确的定义； 2、堆是程序运行期间动态分配的内存空间，你可以根据程序的运行情况确定要分配的堆内存的大小。 请说明php中传值与传引用的区别。什么时候传值什么时候传引用?按值传递：函数范围内对值的任何改变在函数外部都会被忽略 按引用传递：函数范围内对值的任何改变在函数外部也能反映出这些修改 优缺点：按值传递时，php必须复制值。特别是对于大型的字符串和对象来说，这将会是一个代价很大的操作。 按引用传递则不需要复制值，对于性能提高很有好处。 请举例说明在你的开发过程中用什么方法来加快页面的加载速度1、要用到服务器资源时才打开，及时关闭服务器资源2、数据库添加索引3、页面可生成静态4、图片等大文件单独服务器5、使用代码优化工具 get与post两种方式的区别?1、get从服务器获取数据，post向服务器传送数据 2、get传值在url中可见，post在url中不可见 3、get传值一般在2KB以内，post传值大小可以在php.ini中进行设置 4、get安全性非低，post安全性较高，执行效率却比post高 建议：1、get式安全性较Post式要差些包含机密信息建议用Post数据提交式； 2、做数据查询建议用Get式；做数据添加、修改或删除建议用Post方式； 为什么get比post更快1、post请求包含更多的请求头2、post在真正接受数据之前会先将请求头发送给服务器进行确认，然后才真正发送数3、get会将数据缓存起来，而post不会4、post不能进行管道化传输 Cookie和session的区别，禁止了cookie后session能正常使用吗?session的缺点是什么?session在服务器端是存在哪里的?是共有的还是私有的?答：COOKIE保存在客户端，用户通过手段可以进行修改，不安全，单个cookie允许的最大值是3k。 而SESSION保存在服务器端，相对比较安全，大小没有限制。 Session依赖于cookie进行传递。 禁用了cookie之后session不能正常使用。 Session的缺点：保存在服务器端，每次读取都从服务器进行读取，对服务器有资源消耗。 Session保存在服务器端的文件或数据库中，默认保存在文件中，文件路径由php配置文件的session.save_path指定。 Session文件是公有的。 写几个魔术方法并说明作用?__call()调用一个不存在的方法的时候调用 __autoload()在实例化一个尚未被定义的类是会自动调用次方法来加载类文件 __set()在给未定义的属性赋值的时候调用 __get()调用未定义的属性时候调用 __construct()构造方法，实例化类时自动调用的方法 __destroy()销毁对象时自动调用的方法 __unset()当对一个未定义变量调用unset()时自动调用的方法 __isset()当对一个未定义变量调用isset()方法时自动调用的方法 __clone()克隆一个对象 __tostring()当输出一个对象时自动调用的方法 PHP数组排序sort() - 以升序对数组排序rsort() - 以降序对数组排序asort() - 根据值，以升序对关联数组进行排序ksort() - 根据键，以升序对关联数组进行排序arsort() - 根据值，以降序对关联数组进行排序krsort() - 根据键，以降序对关联数组进行排序 数组中下标最好是什么类型的，为什么?数组的下标最好是数字类型的，数字类型的处理速度快 ++i和i++哪一个效率高，为什么?++i效率比i++的效率更高，因为++i少了一个返回i的过程。 echo()、print()、print_r()的区别?echo 是php语法，可以输出多个变量，不能输出数组。 print()是php中的函数，只能输出简单的变量。 print_r()是php中的函数，可以输出变量也可以输出数组。 框架中什么是单一入口和多入口，单一入口的优缺点?1、多入口就是通过访问不同的文件来完成用户请求。单一入口只web程序所有的请求都指向一个脚本文件的 2、单一入口更容易控制权限，方便对http请求可以进行安全性检查。 缺点：URL看起来不那么美观，特别是对搜索引擎来说不友好。 提示类型200、404、502是什么意思。1、200是请求成功 2、404是文件未找到 3、502是服务器内部错误 include，include_once，require，require_once的区别1、include,require在其被调用的位置处包含一个文件。 2、include_once,require_once函数的作用与include相同，不过它会首先验证是否已包含该文件。如果已经包含，则不再执行include_once。其他同include一样。 3、require与include最主要的区别，a、require出错时，脚本将停止运行，而include出错的情况下，脚本将继续执行。b、无论require的位置如何，制定文件都将包含到出现require的脚本中。例如，即使require放在计算结果为假的if语句中，依然会包含指定文件。 4、使用require_once可以解决文件被覆盖的问题。 require_once函数确保文件只包含一次。在遇到require_once后，后面再试图包含相同的文件时将被忽略。 PHP字符串中单引号与双引号的区别?单引号不能解释变量，而双引号可以解释变量。单引号不能转义字符，在双引号中可以转义字符。 php中,模板引擎的目的是什么? 你用过哪些模板引擎?使用模板引擎的目的是使程序的逻辑代码和html界面代码分离开，是程序的结构更清晰。使用过的模板引擎：Smarty、ThinkPHP的ThinkTemplate 什么是跨域？跨域，指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器施加的安全限制 解决：1、CORS（跨资源共享）在php接口脚本中加入以下两句即可：header(‘Access-Control-Allow-Origin:*’);//允许所有来源访问header(‘Access-Control-Allow-Method:POST,GET’);//允许访问的方式 2、JSONP。要注意JSONP只支持GET请求，不支持POST请求 怎么保证促销商品不会超卖第一种方案是：在每次下订单前我们判断促销商品的数量够不够，不够不允许下订单，更改库存量时加上一个条件，只更改商品库存大于0的商品的库存，当时我们使用ab进行压力测试，当并发超过500，访问量超过2000时，还是会出现超卖现象。 第二种方案是：使用mysql的事务加排他锁来解决，首先我们选择数据库的存储引擎为innoDB，使用的是排他锁实现的，刚开始的时候我们测试了下共享锁，发现还是会出现超卖的现象。有个问题是，当我们进行高并发测试时，对数据库的性能影响很大，导致数据库的压力很大 第三种方案是：使用文件锁实现。当用户抢到一件促销商品后先触发文件锁，防止其他用户进入，该用户抢到促销品后再解开文件锁，放其他用户进行操作。这样可以解决超卖的问题，但是会导致文件得I/O开销很大。 最后我们使用了redis的队列来实现。将要促销的商品数量以队列的方式存入redis中，每当用户抢到一件促销商品则从队列中删除一个数据，确保商品不会超卖。这个操作起来很方便，而且效率极高，最终我们采取这种方式来实现 你对Memcach的理解，优点有哪些?Memcache是一种缓存技术，在一定的时间内将动态网页经过解析之后保存到文件，下次访问时动态网页就直接调用这个文件，而不必在重新访问数据库。使用memcache做缓存的好处是：提高网站的访问速度，减轻高并发时服务器的压力。 Memcache的优点：稳定、配置简单、多机分布式存储、速度快。 redis和memcacahe、mongoDB的区别？都是非关系型数据库，性能都非常高，但是mongoDB和memcache、redis是不同的两种类型。后两者主要用于数据的缓存，前者主要用在查询和储存大数据方面，是最接近数据库的文档型的非关系数据库。 1、从数据存储位置上来分，memcache的数据存在内存中，而redis既可以存储在内存中，也可以存储的到磁盘中，达到持久化存储的功能，memcache一旦断电，数据全部丢失，redis可以利用快照和AOF把数据存到磁盘中，当恢复时又从磁盘中读取到内存中，当物理内存使用完毕后，可以把数据写入到磁盘中。 2、从存储数据的类型上来分，memcache和redis存储的方式都是键值对，只不过redis值的类型比较丰富，有string(字符串),hash(哈希)，list(列表),set(集合)zset(有序集合)，而memcache主要存储的是字符串。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>理论知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql面试（理论）]]></title>
    <url>%2F2017%2F02%2F28%2Fmysql-knowledge%2F</url>
    <content type="text"><![CDATA[本页面主要用于编写mysql理论知识，有时间多看看巩固一下！ 什么是事务？及其特性？事务：是一系列的数据库操作，是数据库应用的基本逻辑单位 事务特性：1、原子性：即不可分割性，事务要么全部被执行，要么就全部不被执行。 2、一致性或可串性：事务的执行使得数据库从一种正确状态转换成另一种正确状态 3、隔离性：在事务正确提交之前，不允许把该事务对数据的任何改变提供给任何其他事务， 4、持久性：事务正确提交后，其结果将永久保存在数据库中，即使在事务提交后有了其他故障，事务的处理结果也会得到保存。 MySQL数据库中的字段类型varchar和char的主要区别是什么?哪种字段的查找效率更高，为什么?1、varchar是变长，节省存储空间，char是固定长度。 2、char型查找效率更高。因为varchar是非定长，必须先查找长度，然后进行数据的提取，比char定长类型多了一个步骤，所以效率低一些 MyISAM 和 InnoDB 的基本区别?1、MYISAM不支持外键和事务处理，采用表锁机制，查询速度稍快，数据存储文件有3个 2、InnoDB支持外键和事务处理，采用行锁机制，查询速度比MYISAM稍慢，数据存储文件只有一个。 对关系型数据库而言，索引是相当重要的概念，请回答有关索引几个问题:a) 索引的目的是什么? b) 索引对数据库系统的负面影响是什么? c) 为数据表建立索引的原则有哪些? d) 什么情况下不宜建立索引? 答：索引的目的： 1、快速访问数据表中的特定信息，提高检索速度 2、创建唯一性索引，保证数据库表中每一行数据的唯一性 3、加速表和表之间的连接 4、使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间 负面影响：创建索引和维护索引需要耗费时间，这个时间随着数据量的增加而增加；索引需要占用物理空间，不光是表需要占用数据空间，每个索引也需要占用物理空间；当对表进行增、删、改的时候索引也要动态维护，这样就降低了数据的维护速度。 建立索引的原则： 1、在最频繁使用的、用于缩小查询范围的字段上建立索引 2、需要排序的字段上建立索引 什么情况下不宜建立索引： 1、对于查询中很少涉及的列或者重复值比较多的列，不宜建立索引 2、对于一些特殊的数据类型，不宜建立索引，比如文本字段(text)等。 主键、外键和索引的区别定义的区别：主键：唯一标识一条记录，不能有重复的，不允许为空 外键：表的外键是另一表的主键, 外键可以有重复的, 可以是空值 索引：是对数据库表中一列或多列的值进行排序的一种结构 作用的区别：主键：用来保证数据完整性 外键：用来和其他表建立联系用的 索引：是提高查询排序的速度 个数的区别：主键：主键只能有一个 外键：一个表可以有多个外键 索引：一个表可以有多个唯一索引 说说对SQL语句优化有哪些方法？1、对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。 2、应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。 3、应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如： select id from t where num is null 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询： select id from t where num=0 4、应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如： select id from t where num=10 or num=20 可以这样查询： select id from t where num=10 union all select id from t where num=20 5、下面的查询也将导致全表扫描： select id from t where name like ‘%abc%’ 若要提高效率，可以考虑全文检索。 6、in 和 not in 也要慎用，否则会导致全表扫描，如： select id from t where num in(1,2,3) 对于连续的数值，能用 between 就不要用 in 了： select id from t where num between 1 and 3 7、如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描： select id from t where num=@num 可以改为强制查询使用索引： select id from t with(index(索引名)) where num=@num 8、应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如： select id from t where num/2=100 应改为: select id from t where num=100*2 9、应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如： select id from t where substring(name,1,3)=’abc’–name以abc开头的id select id from t where datediff(day,createdate,’2005-11-30’)=0–’2005-11-30’生成的id 应改为: select id from t where name like ‘abc%’ select id from t where createdate&gt;=’2005-11-30’ and createdate&lt;’2005-12-1’ 10、不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。 11、在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。 12、不要写一些没有意义的查询，如需要生成一个空表结构：select col1,col2 into #t from t where 1=0这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样：create table #t(…) 13、很多时候用 exists 代替 in 是一个好的选择：select num from a where num in(select num from b)用下面的语句替换：select num from a where exists(select 1 from b where num=a.num) 14、并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。 15、索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。 16、应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。 17、尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。 18、尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。 19、任何地方都不要使用 select from t ，用具体的字段列表代替“”，不要返回用不到的任何字段。 20、尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。 21、避免频繁创建和删除临时表，以减少系统表资源的消耗。 22、临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。 23、在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。 24、如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。 25、尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。 26、使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。 27、与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。 28、在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。 29、尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。 30、尽量避免大事务操作，提高系统并发能力。 web应用中,数据库的读取频率远高于写入频率, 如何优化MySQL而应对此种情景 ?1、使用memcache缓存技术，将动态数据缓存到文件，访问动态页面时直接调用缓存文件，而不必重新访问数据库，这样就减少了查询数据库的次数。 2、如果网站的访问量很大，可以把数据库读写服务器分开，使用多态服务器去处理数据库查询，使用较少的服务器去处理数据库的写入和修改。 3、页面静态化 MySQL数据库作发布系统的存储，一天五万条以上的增量，预计运维三年,怎么优化？1、设计良好的数据库结构，允许部分数据冗余，尽量避免join查询，提高效率。 2、选择合适的表字段数据类型和存储引擎，适当的添加索引。 3、mysql库主从读写分离。 4、找规律分表，减少单表中的数据量提高查询速度。 5、添加缓存机制，比如memcached，apc等。 6、不经常改动的页面，生成静态页面。 7、书写高效率的SQL。比如 SELECT * FROM TABEL 改为 SELECT field_1, field_2, field_3 FROM TABLE 写出三种以上MySQL数据库存储引擎的名称MyISAM、InnoDB、BDB（Berkeley DB）、Merge、Memory（Heap）、Example、Federated、Archive、CSV、Blackhole、MaxDB 等等十几个引擎 指出以下代码片段中的SQL注入漏洞以及解决方法(magic_quotes_gpc = off)1mysql_query("select id,title from content where catid='&#123;$_GET[catid]&#125;' and title like '%$_GET[keywords]%'", $link); 注入漏洞主要存在用户提交的数据上，这里的注入漏洞主要是$_GET[catid]和$_GET[keyword] 解决注入漏洞：1234567$_GET[catid]=intval($_GET[catid]);$sql="select id,title from content where catid='&#123;$_GET[catid]&#125;' and title like '%$_GET[keywords]%";$sql=addslashes($sql);mysql_query($sql); SQL语言包括哪几部分？每部分都有哪些操作关键字？答：SQL语言包括数据定义(DDL)、数据操纵(DML),数据控制(DCL)和数据查询（DQL）四个部分。 数据定义：Create Table,Alter Table,Drop Table, Craete/Drop Index等 数据操纵：select ,insert,update,delete, 数据控制：grant,revoke 数据查询：select 什么是锁？1、数据库是一个多用户使用的共享资源。当多个用户并发地存取数据时，在数据库中就会产生多个事务同时存取同一数据的情况。若对并发操作不加控制就可能会读取和存储不正确的数据，破坏数据库的一致性。 2、加锁是实现数据库并发控制的一个非常重要的技术。当事务在对某个数据对象进行操作前，先向系统发出请求，对其加锁。加锁后事务就对该数据对象有了一定的控制，在该事务释放锁之前，其他的事务不能对此数据对象进行更新操作。 3、基本锁类型：锁包括行级锁和表级锁 完整性约束包括哪些？1、数据完整性(Data Integrity)是指数据的精确(Accuracy)和可靠性(Reliability)。(1) 实体完整性：规定表的每一行在表中是惟一的实体。(2) 域完整性：是指表中的列必须满足某种特定的数据类型约束，其中约束又包括取值范围、精度等规定。(3) 参照完整性：是指两个表的主关键字和外关键字的数据应一致，保证了表之间的数据的一致性，防止了数据丢失或无意义的数据在数据库中扩散。(4) 用户定义的完整性：不同的关系数据库系统根据其应用环境的不同，往往还需要一些特殊的约束条件。用户定义的完整性即是针对某个特定关系数据库的约束条件，它反映某一具体应用必须满足的语义要求。 2、与表有关的约束：包括列约束(NOT NULL（非空约束）)和表约束(PRIMARY KEY、foreign key、check、UNIQUE) 。 什么叫视图？游标是什么？1、视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，视图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。 2、游标：是对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行。可以对结果集当前行做修改。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。 试述视图的优点？1、视图能够简化用户的操作 2、视图使用户能以多种角度看待同一数据 3、视图为数据库提供了一定程度的逻辑独立性 4、视图能够对机密数据提供安全保护。 什么是存储过程？用什么来调用？1、存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。 2、可以用一个命令对象来调用存储过程。]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>面试</tag>
        <tag>理论知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建SVN服务器]]></title>
    <url>%2F2017%2F02%2F26%2Fserver-build-svn%2F</url>
    <content type="text"><![CDATA[在 Centos5.5 上搭建SVN服务器并实现自动同步至web目录。 一、搭建svn环境并创建仓库：安装Subversion1yum install -y subversion 检测是否安装成功(查看svn版本号)1svnserve --version 创建版本库（没有规定在哪创建目录）12345mkdir /home/svn //先建目录cd /home/svn //进入目录svnadmin create /home/svn/test //创建版本库cd test //进入创建的版本库ls //会看到自动生成的版本库文件（如下图） 创建用户组及用户进入版本库中的配置目录conf 修改权限配置文件1vim authz 配置用户名命令文件1vim passwd 配置SVN服务综合配置文件1vim svnserve.conf //找到以下配置项，将前面的#号去掉（注意：所有配置项前面不能留空格），然后做相应的配置anon-access = none //匿名用户访问权限:无auth-access = write //普通用户访问权限:写password-db = passwd //引入密码文件authz-db = authz //引入权限配置文件realm = /home/svn/test //版本库所在 启动svn服务1svnserve -d -r /home/svn 其中 -d表示(独立端口运行) -r表示(仓库地址)svn服务走svn协议，端口号是3690 如果提示：svnserve: E000098: Can’t bind server socket: Address already in use证明现在svn已经被启动了，由于我们修改了配置文件，因此要重启svn服务，所以要先关闭svn再重启svn 查看svn服务详情（如下图所示）1ps aux | grep svn 将svn服务强制停止 其中790为svn服务的ID号，-9是kill的参数1kill -9 790 最后再重新运行 svnserve -d -r /var/svn 测试有没有成功123cd /wwwmkdir testsvn co svn://localhost/test /www/test --username vonfly(SVN账号) --password vonfly(SVN密码) 如果提示：Checked out revision 0.表示checkout成功 本地拉取、推送（本地要先安装SVN客户端）输入远程链接：svn://服务器iP地址/test，再输入用户名和密码即可链接 本地commit时自动同步到web目录实现本地更新同步到服务器项目：配置项目仓库的钩子配置,可以把钩子看成是WEB项目于SVN项目仓库之间的一个关联，通过向SVN项目仓库提交脚本代码，利用钩子shell脚本可以自动向web项目中将脚本文件更新过去 进入/var/svn/project/hooks下，建立post-commit文件12cd /var/svn/project/hooksvim post-commit 在该文件里添加如下代码： #!/bin/shexport LANG=zh_CN.UTF-8SVN_PATH=/usr/bin/svn //这里不用改WEB_PATH=/www/test //对应自己web目录//这里的用户随便一个就好$SVN_PATH update $WEB_PATH –username ‘vonfly’ –password ‘vonfly’ –no-auth-cache 给post-commit 执行权限1chmod 755 post-commit 扩展具体权限表示r(read)读【有update操作】 w(write)写【有commit操作】 开启只操作某个目录的权限要求：给帐号设置只操作temp目录的权限，只能给操作temp目录的用户只读权限对应的权限文件（authz）设置[test:/temp]temp1 = rtemp2 = r…..对应的本地客户端拉取就要：输入远程链接：svn://服务器iP地址/test/temp说明：这样的设置不会影响到之前[test:/]的设置，两个设置可以共存]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Centos</tag>
        <tag>SVN</tag>
        <tag>版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sublime使用技巧]]></title>
    <url>%2F2017%2F02%2F17%2Fsublime%2F</url>
    <content type="text"><![CDATA[sublime使用技巧，平时用的时候觉得不错的功能就会把它分享给大家(●’◡’●) sublime右键快捷方式添加window下，开始-&gt;运行-&gt;regedit到 HKEY_CLASSES_ROOT*\shell目录下新建sublime(随便你起什么名字)再到新建好的sublime目录下新建command(固定名字) 最后的目录结构【HKEY_CLASSES_ROOT*\shell\sublime\command】 第一个双引号是你的软件安装目录“E:\Sublime Text 3 Build 3103 x64 Portable Cracked (2016.02.11)\sublime_text.exe” -p –remote-tab-silent “%1” window如何查看软件安装目录，如下图说明： 选中上一步建好的文件command，然后双击右边的默认，把上边的内容复制进去即可。如下图说明 随便找个文件sublime能够识别的文件，鼠标右击就可以看到刚刚添加的快捷键了，可以直接打开 Sublime text 2/3 中 Package Control 的安装与使用方法从菜单 View - Show Console 或者 ctrl + ~ 快捷键，调出 console。将以下 Python 代码粘贴进去并 enter 执行，不出意外即完成安装。以下提供 ST3 和 ST2 的安装代码： Sublime Text 3：1import urllib.request,os; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), 'wb').write(urllib.request.urlopen( 'http://sublime.wbond.net/' + pf.replace(' ','%20')).read()) Sublime Text 2：1import urllib2,os; pf='Package Control.sublime-package'; ipp = sublime.installed_packages_path(); os.makedirs( ipp ) if not os.path.exists(ipp) else None; urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler( ))); open( os.path.join( ipp, pf), 'wb' ).write( urllib2.urlopen( 'http://sublime.wbond.net/' +pf.replace( ' ','%20' )).read()); print( 'Please restart Sublime Text to finish installation') 常用的一些插件：AdvancedNewFile 快速创建新文件Better Completion 全能代码提示(需要自己配置一下插件，需要提示的库)CodeFormatter 代码格式化ConverToUTF8 支持 GBK, BIG5, EUC-KR, EUC-JP, Shift_JIS 等编码的插件DocBlockr 代码块注释EmmetFile Header 自动更新保存时间，文件模板Side BarMonokai Extended 主题配置SideBarEnhancements 增强型侧边栏]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>软件使用技巧</tag>
        <tag>右键快捷方式添加</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识gulp]]></title>
    <url>%2F2016%2F11%2F02%2Fgulp%2F</url>
    <content type="text"><![CDATA[初识gulp自动化构建工具。一开始只是听过这个东西，没有尝试用过。听起来好像很高大上的样子，一直想要去尝试用一下，但一直没有去用过。一来现在的项目没有用到；二来之前好像确实是挺忙的，没有找到什么合适的时间去尝试用下；三来嘛感觉这么高大上的东西可能学起来应该会很难，会花费很多时间。ps：很多事情只有去尝试了才会知道难不难，很多东西你觉得难可能是因为你没有用过它，或者不知道它是用来做什么的，只有你勇敢的踏出一步去尝试用下，你就会发现其实没有那么难。(●’◡’●) 介绍通过代码优于配置的策略，Gulp 让简单的任务简单，复杂的任务可管理。利用 Node.js 流的威力，你可以快速构建项目并减少频繁的 IO 操作。Gulp 严格的插件指南确保插件如你期望的那样简洁高质得工作。通过最少的 API，掌握 Gulp 毫不费力，构建工作尽在掌握：如同一系列流管道。 入门指南 全局安装 gulp： 1$ npm install --global gulp 作为项目的开发依赖（devDependencies）安装： 1$ npm install --save-dev gulp 在项目根目录下创建一个名为 gulpfile.js 的文件：var gulp = require(‘gulp’); gulp.task(‘default’, function() { // 将你的默认的任务代码放在这}); 运行 gulp：1$ gulp default 如博客gulpfile.js代码为:123456789101112var gulp = require('gulp');var minifycss = require('gulp-minify-css');var uglify = require('gulp-uglify');var htmlmin = require('gulp-htmlmin');var imagemin = require('gulp-imagemin');// 压缩htmlgulp.task("minhtml",function()&#123; return gulp.src("public/**/*.html") .pipe(htmlmin()) .pipe(gulp.dest("./public"))&#125;); 常用的一些插件 gulp-minify-css 压缩css gulp-uglify 压缩js gulp-htmlmin 压缩html gulp-imagemin 压缩图片 安装1$ npm install [plugins-name] --save 上述命令安装插件的同时也会把插件作为项目依赖写入package.json文件. 参考：guly官网(包含插件搜索)guly中文网站]]></content>
      <categories>
        <category>自动化构建工具</category>
      </categories>
      <tags>
        <tag>gulp</tag>
        <tag>代码优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些常用的linux-commands]]></title>
    <url>%2F2016%2F09%2F06%2Flinux-commands%2F</url>
    <content type="text"><![CDATA[常用的一些Linux命令 目录操作查看目录下的文件123lsls -l //显示文件的详细信息(包括权限信息)ls -al //显示文件的详细信息(包括隐藏文件) 目录切换1cd 目录名字 创建目录12mkdir newdir1 //创建单个新目录mkdir -p newdir1/newdir2/newdir3 //递归创建多级目录 移动目录12mv dir1 dir2 //dir1目录移动到dir2的目录下mv dir1 newdir //dir1移动到当前目录下，并改名字为newdir 复制（复制目录一般要加-R参数）12cp -R dir1 newdir //dir1复制到当前目录，并改名字为 newdircp file dir1 //file文件复制到dir1下 删除12rm file //删除file文件rm -rf dir //递归强制删除目录 查看当前操作目录位置1pwd 文件操作文件内容查看123456cat filename //一次性把全部内容输出到终端more filename //通过敲回车方式逐行查看文件内容，q键结束查看less filename //&quot;上下左右&quot;键方式查看文件各部分内容，q键结束查看head -n filename //查看文件的前n行内容tail -n filename //查看文件的最后n行内容wc filename //查看文件内容行数 创建文件1touch filename //在当前目录创建filename文件 给文件追加内容123echo 内容 &gt; 文件 //把内容以覆盖写方式添加到文件中echo 内容 &gt;&gt; 文件 //把内容以追加方式添加到文件中//例：echo vonfly &gt; test 说明：如果文件不存在会自动创建 文件主人、组别设置12chown 主人 filenamechown 主人.组别名称 filename ##组和用户的操作 组的操作对应配置文件：/etc/group12groupadd 组名 //创建组（例：groupadd php）创建php这个组groupmod -n 新组名 原组名 //修改组（例：groupmod -n php python）把php这个组修改成python 用户的操作对应配置文件：/etc/passwd123useradd -g 组编号 用户名 //创建用户，顺便分组usermod -l 新用户名 原用户名 //修改用户名userdel -r 用户名 //删除用户信息同时删除用户家目录 设置用户密码1passwd 用户名 //例：passwd vonfly (给vonfly设置新密码) 权限操作字母相对方式设置权限12chmod u+/-rwx,g+/-rwx,o+/-rwx filename //主人，同组用户，其他组用户增加或减少权限，可以设置一个或多个权限chmod +w,-x filename //统一给每一个组别设置统一权限（相当于给主人，同组用户，其他组用户增加了读的权限，减少了执行的权限） 数字绝对方式设置权限（会直接覆盖之前的权限）12chmod 621 filename //表示给主人设置成读写权限，同组用户设置写权限，其他组用户设置执行权限chmod -R 777 dirname //-R参数表示递归方式设置目录权限 说明：读：4，写：2，执行：10表示没有权限1表示执行权限2表示写权限3表示写、执行权限4表示读权限5表示读、执行权限6表示读、写权限7表示读、写、执行权限 文件的读写执行具体表示：读：表示是否可以查看文件内容写：表示是否可以修改该文件执行：一般表示执行shell脚本程序文件 目录的读写执行具体表示：读：表示是否可以查看该目录下的文件信息写：表示是否可以给该目录创建、删除文件执行：表示用户是否可以通过cd进入该目录 find文件查找指令参数说明 选项 描述 -name 根据文件名字查找文件 -size 根据文件大小查找文件 -maxdepth 限制最深层次查找文件 -mindepth 限制最浅层次查找文件 -perm 把符合某个权限的文件给查找出来 -user 根据主人查找文件 -group 根据组别查找文件 例子： 123456789find /home -name vonfly //在home目录下查找vonfly文件find /home -name &quot;v*&quot; //在home目录下模糊查找带v字符开始的文件find /home -size 100c //在home目录下找大小为100字节的文件find /home -size 100 //在home目录下找大小为100*512字节的文件find /home -size +10k //在home目录下找大小大于10的文件find /home -size -10k //在home目录下找大小小于10的文件find /home -maxdepth 3 -name vonfly //在home目录下限制最深为3个目录层次，进行vonfly文件查找 其它操作查看指令可以使用的参数1man 指令名称 //例：man useradd 用户切换123su - //切换到root超级管理员su vonfly //切换到vonfly普通用户exit //退回到原用户 说明：一般su和exit是配对使用的，否则用户切换会叠加 查看当前用户是谁12whoami //显示当前正在操作系统的用户who am i //显示登录系统的用户 查看指令对应的可执行(二进制)文件位置1which 指令名称 (如：which pwd) 查看系统活跃的进程12ps -Aps -aux 将文本指定的信息匹配出来1grep 关键字 文件的路径 //例：grep php ./test.txt 表示在当前文件test.txt中找php关键字 通过进程名称来查询程序(如mysql)是否有启用（管道使用）12ps aux | grep mysqlpstree -p | grep mysql //方法2 通过端口查看程序是否有启用（管道使用）123netstat -anpl | grep 3306 //查看mysql（默认监听3306端口）netstat -anpl | grep 9000 //查看php（默认监听9000端口）netstat -tunpl | grep :3306 //方法2 查看系统分区情况12df -lhdf -h 查看目录或者文件的大小1du -h filename 关闭指定进程号的进程12kill -9 pid //强制关闭kill -15 pid //正常关闭 查看内存使用1free -m 查看CPU使用1top 关机1shutdown -h now 可以切换终端1alt+f(1-6),共有6个终端 实时跟踪一个命令的执行结果(如跟踪ls -lh命令)12可以切换终端来查看具体效果watch -n1 ls -lh 加压方式12.tar.gz------------------&gt; tar zxvf 压缩包名.tar.gz.tar.bz2-----------------&gt; tar jxvf 压缩包名.tar.bz2]]></content>
      <categories>
        <category>命令</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些常用的git-commands]]></title>
    <url>%2F2016%2F06%2F18%2Fgit-commands%2F</url>
    <content type="text"><![CDATA[常用的一些git命令以及平时项目遇到的一些问题解决方法 git一些命令在当前目录新建一个Git代码库1$ git init 新建一个目录，将其初始化为Git代码库 1$ git init [project-name] 下载一个项目和它的整个代码历史 1$ git clone [url] 增加/删除文件添加指定文件到暂存区1$ git add [file1] [file2] ... 添加指定目录到暂存区，包括子目录1$ git add [dir] 将所有修改过的工作文件提交暂存区1$ add . 添加每个变化前，都会要求确认，对于同一个文件的多处变化，可以实现分次提交1$ git add -p 删除暂存区文件1$ git rm file.name (工作区和暂存区都存在的情况下)删除工作区文件，同时删除暂存区文件1$ git rm -f file.name (工作区和暂存区都存在的情况下)不删除工作区文件，删除暂存区文件1$ git rm --cached file.name 改名文件，并且将这个改名放入暂存区1$ git mv [file-original] [file-renamed] 代码提交提交暂存区到仓库区（提交说明要用英文引号）1$ git commit -m [提交说明] 提交暂存区到仓库区1$ git commit [file1] [file2] ... -m [提交说明] 分支列出所有本地分支1$ git branch 列出所有远程分支1$ git branch -r 列出所有本地分支和远程分支1$ git branch -a 新建一个分支，但依然停留在当前分支1$ git branch [branch-name] 新建一个分支，并切换到该分支1$ git checkout -b [branch] 新建一个分支，指向指定commit1$ git branch [branch] [commit] 新建一个分支，与指定的远程分支建立追踪关系1$ git branch --track [branch] [remote-branch] 切换到指定分支，并更新工作区1$ git checkout [branch-name] 切换到上一个分支1$ git checkout - 建立追踪关系，在现有分支与指定的远程分支之间1$ git branch --set-upstream [branch] [remote-branch] 合并指定分支到当前分支1$ git merge [branch] 选择一个commit，合并进当前分支1$ git cherry-pick [commit] 删除分支1$ git branch -d [branch-name] 删除远程分支12$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 查看信息显示有变更的文件1$ git status 显示当前分支的版本历史1$ git log 显示之后版本历史1$ git reflog 显示commit历史，以及每次commit发生变更的文件1$ git log --stat 搜索提交历史，根据关键词1$ git log -S [keyword] 显示某个文件的版本历史，包括文件改名12$ git log --follow [file]$ git whatchanged [file] 显示指定文件相关的每一次diff1$ git log -p [file] 显示过去5次提交1$ git log -5 --pretty --oneline 显示指定文件是什么人在什么时间修改过1$ git blame [file] 显示暂存区和工作区的差异1$ git diff 显示暂存区和上一个commit的差异1$ git diff --cached [file] 显示工作区与当前分支最新commit之间的差异1$ git diff HEAD 显示两次提交之间的差异1$ git diff [first-branch]...[second-branch] 远程同步下载远程仓库的所有变动1$ git fetch [remote] 显示所有远程仓库1$ git remote -v 显示某个远程仓库的信息1$ git remote show [remote] 增加一个新的远程仓库，并命名1$ git remote add [shortname] [url] 取回远程仓库的变化，并与本地分支合并1$ git pull [remote] [branch] 上传本地指定分支到远程仓库1$ git push [remote] [branch] 推送所有分支到远程仓库1$ git push [remote] --all 撤销恢复暂存区的指定文件到工作区1$ git checkout [file] 恢复某个commit的指定文件到暂存区和工作区1$ git checkout [commit] [file] 恢复暂存区的所有文件到工作区1$ git checkout . 整个版本的撤销重置暂存区的指定文件，与上一次commit保持一致，但工作区不变1$ git reset [file] 重置暂存区与工作区，与上一次commit保持一致1$ git reset --hard [commit] 显示当前的Git配置1$ git config --list 编辑Git配置文件1$ git config -e [--global] 设置提交代码时的用户信息12$ git config [--global] user.name "your username"$ git config [--global] user.email "your e-mail" 扩展多人协作解决冲突推荐方法1：123$ git fetch$ git diff master origin/master$ git merge orgin/master 方法2：1$ git pull 参考：阮一峰-常用 Git 命令清单]]></content>
      <categories>
        <category>命令</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>命令使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多台电脑共同管理hexo博客]]></title>
    <url>%2F2016%2F02%2F18%2Fhexo-version-control%2F</url>
    <content type="text"><![CDATA[使用hexo搭建博客，如果换了电脑怎么更新博客？如果你有备份源文件那还好，但是每次都要备份感觉太麻烦了。这里介绍一种方法就是使用github分支。一个分支用来存放Hexo生成的网站原始的文件，另一个分支用来存放生成的静态网页。 有博客源文件时，博客源文件我们放到hexo分支上先删除主题文件下的.git文件，可以直接删除或者执行下面的命令 1$ rm -rf .git 然后在本地博客文件夹下边依次输入以下指令(部分指令因为有提示可以自己修改下) 123456$ git init$ git checkout -b hexo$ git remote add origin git@github.com:vonfly（你自己giuhub账号名）/vonfly.github.io（项目名）.git$ git add .$ git commit -m "提交说明"$ git push origin hexo 执行到这里我们就已经把本地的源文件添加到了分支hexo上。 从github分支上拉取博客源文件1234$ git clone -b hexo git@github.com:vonfly/vonfly.github.io$ npm install // 安装需要的包$ hexo generate // 生成静态文件$ hexo server -p 3000 // 本地服务测试查看 我的.gitignore文件内容为.DS_StoreThumbs.dbdb.json.lognode_modules/public/.deploy/ 当然你也可以把node_modules/去掉，这样在另外的电脑克隆下来的项目就不用在运行上面的命令了 扩展： github常见操作和常见错误！如果输入$ git remote add origin git@github.com:vonfly（github帐号名）/vonfly.github.io（项目名）.git提示出错信息：fatal: remote origin already exists. 解决办法如下： 1、先输入$ git remote rm origin 2、再输入$ git remote add origin git@github.com:vonfly/vonfly.github.io.git 就不会报错了！ 如果输入$ git remote rm origin 还是报错的话，error: Could not remove config section ‘remote.origin’. 我们需要修改gitconfig文件的内容4、找到你的github的安装路径，我的是C:\Users\ASUS\AppData\Local\GitHub\PortableGit_ca477551eeb4aea0e4ae9fcd3358bd96720bb5c8\etc5、找到一个名为gitconfig的文件，打开它把里面的[remote “origin”]那一行删掉就好了！ 如果输入$ git push origin master提示出错信息：error:failed to push som refs to …….解决办法如下： 1、先输入$ git pull origin master //先把远程服务器github上面的文件拉下来 2、再输入$ git push origin master 3、如果出现报错 fatal: Couldn’t find remote ref master或者fatal: ‘origin’ does not appear to be a git repository以及fatal: Could not read from remote repository. 4、则需要重新输入$ git remote add origin git@github.com:vonfly/vonfly.github.io.git]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的一些命令]]></title>
    <url>%2F2016%2F02%2F16%2Fcommon-commands%2F</url>
    <content type="text"><![CDATA[平时写博客会用到的一些命令 hexo命令init 新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。1$ hexo init [folder] new 新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。1$ hexo new [layout] &lt;title&gt; generate 生成网站(即生成静态文件)1$ hexo generate 参数说明 选项 描述 -d, –deploy 文件生成后立即部署网站 -w, –watch 监视文件变动 server 启动服务器。默认情况下，访问网址为： http://localhost:4000/。1$ hexo server 参数说明 选项 描述 -p, –port 重设端口 -s, –static 只使用静态文件 -l, –log 启动日志记录，使用覆盖记录格式 deploy 部署网站。1$ hexo deploy 参数说明 选项 描述 -g, –generate 部署之前预先生成静态文件 clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)。1$ hexo clean version 显示 Hexo 版本。1$ hexo version 安装 Hexo Algolia 扩展（用于页面搜索）1$ npm install hexo-algolia@0.2.0 来更新 Index（相当于把博客下的文章更新到algolia数据库）1$ hexo algolia]]></content>
      <categories>
        <category>命令</category>
      </categories>
      <tags>
        <tag>命令使用</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown语法-本页面主要用于自己学习]]></title>
    <url>%2F2016%2F02%2F07%2Fmarkdown-grammar%2F</url>
    <content type="text"><![CDATA[本页面主要用于自己学习的，方便以后写作。当然了，偶尔忘记可以查看一下，文章最底下也有链接，大家可以查看链接的语法说明(●’◡’●) 欢迎使用 Cmd Markdown 编辑阅读器 我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，Cmd Markdown 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown： 整理知识，学习笔记 发布日记，杂文，所见所想 撰写发布技术文稿（代码支持） 撰写发布学术论文（LaTeX 公式支持） 除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载： Windows/Mac/Linux 全平台客户端 请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 新文稿 或者使用快捷键 Ctrl+Alt+N。 什么是 MarkdownMarkdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字，更棒的是，它还可以 1. 制作一份待办事宜 Todo 列表 [ ] 支持以 PDF 格式导出文稿 [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 [x] 新增 Todo 列表功能 [x] 修复 LaTex 公式渲染问题 [x] 新增 LaTex 公式编号功能 2. 书写一个质能守恒公式[^LaTeX]$$E=mc^2$$ 3. 高亮一段代码[^code]1234567@requires_authorizationclass SomeClass: passif __name__ == '__main__': # A comment print 'hello world' 4. 高效绘制 流程图12345678st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 5. 高效绘制 序列图123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 6. 高效绘制 甘特图12345678910111213title 项目开发流程section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5dsection 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5dsection 发布验收 发布: 2d 验收: 3d 7. 绘制表格 项目 价格 数量 计算机 \$1600 5 手机 \$12 12 管线 \$1 234 8. 更详细语法说明想要查看更详细的语法说明，可以参考我们准备的 Cmd Markdown 简明语法手册，进阶用户可以参考 Cmd Markdown 高阶语法手册 了解更多高级功能。 总而言之，不同于其它 所见即所得 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。 什么是 Cmd Markdown您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 编辑/发布/阅读 Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。 1. 实时同步预览我们将 Cmd Markdown 的主界面一分为二，左边为编辑区，右边为预览区，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！ 2. 编辑工具栏也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 编辑区 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。 3. 编辑模式完全心无旁骛的方式编辑文字：点击 编辑工具栏 最右侧的拉伸按钮或者按下 Ctrl + M，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！ 4. 实时的云端文稿为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 编辑工具栏 的最右侧提示 已保存 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。 5. 离线模式在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。 6. 管理工具栏为了便于管理您的文稿，在 预览区 的顶部放置了如下所示的 管理工具栏： 通过管理工具栏可以： 发布：将当前的文稿生成固定链接，在网络上发布，分享 新建：开始撰写一篇新的文稿 删除：删除当前的文稿 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地 列表：所有新增和过往的文稿都可以在这里查看、操作 模式：切换 普通/Vim/Emacs 编辑模式 7. 阅读工具栏 通过 预览区 右上角的 阅读工具栏，可以查看当前文稿的目录并增强阅读体验。 工具栏上的五个图标依次为： 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落 视图：互换左边编辑区和右边预览区的位置 主题：内置了黑白两种模式的主题，试试 黑色主题，超炫！ 阅读：心无旁骛的阅读模式提供超一流的阅读体验 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境 8. 阅读模式在 阅读工具栏 点击 或者按下 Ctrl+Alt+M 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。 9. 标签、分类和搜索在编辑区任意行首位置输入以下格式的文字可以标签当前文档： 标签： 未分类 标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示： 10. 文稿发布和分享在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 (Ctrl+Alt+P) 发布这份文档给好友吧！ 再一次感谢您花费时间阅读这份欢迎稿，点击 (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！ 作者 @ghosert2016 年 07月 07日 [^LaTeX]: 支持 LaTeX 编辑显示支持，例如：$\sum_{i=1}^n a_i=0$， 访问 MathJax 参考更多使用方法。 [^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，四十一种主流编程语言。 参考：Cmd Markdown 编辑阅读器Markdown 语法说明 (简体中文版)]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>Markdown语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub+Hexo+Next搭建免费独立个人博客]]></title>
    <url>%2F2016%2F01%2F22%2Fhello-world%2F</url>
    <content type="text"><![CDATA[我为什么要搭建个人博客呢，一来有自己的博客会显得高大尚一点，二来也可以当作学习新知识 搭建步骤node.js Git 是必须工具 安装Git前往Git官网下载Windows版本压缩包，下载完成后解压安装。（一直下一步即可） 当你安装Git后首先要做的事情是设置你的用户名称和e-mail地址。这是非常重要的，因为每次Git提交都会使用该信息。它被永远的嵌入到了你的提交中：在命令行中输入：12$ git config --global user.name "your username"$ git config --global user.email "your e-mail" 重申一遍，你只需要做一次这个设置。如果你传递了 –global 选项，因为Git将总是会使用该信息来处理你在系统中所做的一切操作。如果你希望在一个特定的项目中使用不同的名称或e-mail地址，你可以在该项目中运行该命令而不要–global选项。 安装Node.js前往Node.js官方下载网站，选择适合自己系统的进行下载，下载完成后同样解压安装。（一直下一步即可） 注册Github账户前往Github网站，注册一个新用户。创建一个新的repository 在自己的Github主页右上角的加号,创建一个新的repository。比如我的Github用户名为vonfly，那么我创建的repository的名字应该是 vonfly.github.io 给本机配置SSH-Key打开Git Bash，在命令行中输入： 1$ ssh-keygen -t rsa -C "your e-mail" 之后一直回车，就可以了成功之后在命令行中找到这两段Your identification has been saved in /c/Users/XZY-06/.ssh/id_rsa.Your public key has been saved in /c/Users/XZY-06/.ssh/id_rsa.pub.打开所对应的文件夹，找到 id_rsa.pub文件，用编辑器打开，复制其中的全部内容。登陆你的GitHub账户，依次点击账号Settings &gt; SSH and GPG keys &gt; new SSH key，把id_rsa.pub中的内容拷贝进去key项，title项随意填 。 至此就已经配置完SSH-Key了 安装Hexo（安装需要花一些时间）点击鼠标右键，看是否有Git bash Here选项。如果没有可以前往Git安装根目录，启动git-base.exe也可以。在命令行中输入： 1$ npm install -g hexo-cli 创建myblog文件夹找到想要放置博客的文件夹，比如（F:\myblog），在该目录下鼠标右击打开Gitbash工具。在命令行中输入： 1$ hexo init 这里init后面可以跟文件目录，比如我想在F:\text下创建博客文件夹，那么可以用下面的命令： 1$ hexo init F:\text 安装依赖包在myblog目录下，执行以下命令 1$ npm install 安装完后的目录结构123456├── _config.yml //网站的配置信息（也就是站点配置文件）├── package.json //应用程序数据，指明hexo的版本等信息├── scaffolds //模版文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。├── source //文章源码目录，该目录下的markdown和html文件均会被hexo处理。| ├── _posts //新建的文章都将存放在此目录下。编辑&lt;文件名&gt;.md文件可修改内容。└── themes //主题文件夹。Hexo会根据主题来生成静态页面。 本地调试（在myblog目录下，依次执行以下命令）1.生成网站1$ hexo generate 2.本地服务器1$ hexo server 然后在浏览器中输入 localhost:4000 就可以看到自己的博客了如果打开很慢或者打开不了，可以更改下端口1$ hexo server -p 3000 重新在浏览器中输入 localhost:3000即可，至此我们已经搭建好自己的Hexo博客了，不过博客采用的主题是默认的主题，而我们要使用简洁优雅且易于使用NexT主题 Next主题1.下载Next主题（下载需要一点时间）在myblog目录下，执行以下命令 1$ git clone https://github.com/iissnan/hexo-theme-next themes/next 2.启用Next主题下载完成后，打开站点配置文件(即更目录下的_config.yml)，找到theme字段，并将其值更改为 next。再重新执行本地调试那一步骤的命令查看效果即可 将本地的文件部署（上传）到Github账户中打开站点配置文件(即更目录下的_config.yml)，在最后添加如下代码（在你修改时，把 repository更换成之前步骤创建新的repository仓库地址） 1234deploy: type: git repository: https://github.com/vonfly/vonfly.github.io.git branch: master 执行以下指令即可完成部署（如果提示错误，可以看下面出错原因及解决方法）： 12$ hexo generate$ hexo deploy 1.每次修改本地文件，都需要命令$ hexo generate才能保存。而且每次使用命令都必须在myblog根目录下使用。 2.如果你在执行$ hexo deloy,如果提示 ERROR Deployer not found: git，那说明你没有安装hexo-deployer-git依赖包，进入F:\Hexo\node_modules发现真的没有hexo-deployer-git。解决方法：①只需要输入下面命令创建hexo-deployer-git依赖包 1$ npm install hexo-deployer-git --save ②然后再执行hexo deploy就能上传成功了1$ hexo deploy 直接在浏览器访问vonfly.github.io试试 博客安装和主题配置参考：hexo官网next主题官网]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
